###########################################################################################################################
如何测试embed_tool
1、先清空shadow目录和远端mysql中的数据库
2、启动proxy，调用测试脚本，生成shadow目录
3、把【1】中的aaa目录清空，scp拷贝shadow过去，导出aaa.sql文件。
4、导出xml文件，清空shadow_2，导入shadow_2
5、把【1】中的aaa目录清空，scp拷贝shadow过去，导出bbb.sql文件。
6、对照一把sql文件
7、使用shadow进行测试
8、然后再使用shadow_2测试
	

###########################################################################################################################
密码学有关
密码学6个重要工具：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器


###########################################################################################################################
kms密钥管理服务器
1、kms是密钥管理服务器，需要向kms获取密钥，是否支持用户设置？
2、要向kms获取密钥，需要一组参数，这组参数确定密钥
3、客户端和kms交互，需要会话密钥，这就涉及密钥配送的问题，解决这个问题，使用公钥密码，向服务端请求公钥。
4、客户端请求，使用服务端的公钥SM2，对会话密钥加密。
5、考虑到会话密钥的


3、获取过程是经过网络的，如果请求是明文，第三方可以截取到，存在风险。
4、怎么解决？
	客户端的请求要加密，服务端先传一个公钥。
5、服务端传输的密钥，也需要加密
	需要客户端传输密钥
6、
	

###########################################################################################################################
重要的错误
安装sudo apt install libmysqld-dev
导致assert(0 == mysql_thread_init());//初始化线程环境，断言失败



###########################################################################################################################
同时生成静态库和动态库



###########################################################################################################################
merge
1、如果没有分叉，从dev合并，就是 Fast-forward
2、本地合并，存在冲突。
	
###########################################################################################################################
origin
1、origin是个远程地址，通过下面的语句可以看到
	root@ubuntu:/home/disk1/GitTest# git remote -v
	origin  https://github.com/nzbbody/GitTest (fetch)
	origin  https://github.com/nzbbody/GitTest (push)


###########################################################################################################################
加密模式的区别
1、SENSITIVE等级最高，BEST_EFFORT相对于SENSITIVE，只是多了一个洋葱，支持剥到明文，PLAIN就是明文。
2、BEST_EFFORT和SENSITIVE，会根据实际需要配置洋葱层，在使用的过程中，为了支持，会剥掉洋葱。





###########################################################################################################################
DETJOINFactory 和 DETFactory 什么区别？
std::unique_ptr<EncLayer>
DETFactory::create(const Create_field &cf, const std::string &key)
{
    if (isMySQLTypeNumeric(cf)) {
        if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            FAIL_TextMessageError("decimal support is broken");
        } else {
            return std::unique_ptr<EncLayer>(new DET_int(cf, key));
        }
    } else {
        return std::unique_ptr<EncLayer>(new DET_str(cf, key));
    }
}

std::unique_ptr<EncLayer>
DETFactory::deserialize(unsigned int id, const SerialLayer &sl)
{
    if ("DET_int" == sl.name) {
        return DET_abstract_integer::deserialize<DET_int>(id,
                                                       sl.layer_info);
    } else if ("DET_dec" == sl.name) {
        FAIL_TextMessageError("decimal support broken");
    } else if ("DET_str" == sl.name) {
        return std::unique_ptr<EncLayer>(new DET_str(id, sl.layer_info));
    } else {
        FAIL_TextMessageError("Unknown type for DET deserialization!");
    }
}


###########################################################################################################################
OPE剥洋葱的细节
1、varbinary当成varchar使用
2、RND剥洋葱涉及到salt，其它的剥洋葱不涉及
3、由于加上了OPEJOIN，也就是 【【【OPEJOIN】OPE】RND】
	这就要剥洋葱 OPE， RND剥掉之后，就需要剥掉OPE，秘钥不同
4、为什么不需要 OPE_str::decryptUDF ？
	static onionlayout STR_ONION_LAYOUT = 
	{
    {oDET, std::vector<SECLEVEL>({SECLEVEL::DETJOIN, SECLEVEL::DET,
                                  SECLEVEL::RND})},
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
    {oSWP, std::vector<SECLEVEL>({SECLEVEL::SEARCH})}
    // {oSWP, std::vector<SECLEVEL>({SECLEVEL::PLAINVAL, SECLEVEL::DET,
                                  // SECLEVEL::RND})}
	};
	因为string的OPE是 {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
	string--OPEJOIN-->int--OPE-->int， 这里的OPE是对int处理，所以剥掉的也是OPE_int
5、对于string的OPE操作，只能比较前面4个字节，为什么？
	因为OPE算法只对前面4个字节，加密，加密的结果是 varbinary(32), 32个字节。
6、为什么只对前面4个字节加密？
	因为string的长度是不确定的，没有办法支持加密后的结果进行OPE比较。
7、为什么对前面4个字节加密，select出来的结果，是完整的？
	因为select的是eq这个洋葱，作为判断使用的是ope洋葱。
###########################################################################################################################	
mysql的varbinary
1、select出来varbinary看到的值不是字节的值，而是字节的ASCCI值。如下：
	CREATE TABLE test1 (c1 VARBINARY(3));
	INSERT INTO test1 set c1 = 0x61;
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	+----+
	1 row in set
2、再添加一个记录，如下：
	mysql> INSERT INTO test1 set c1 = 0x31;
	Query OK, 1 row affected
	
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	| 1  |
	+----+
	2 rows in set
	注意：这里的1是ASCCI值，取值为49
###########################################################################################################################
快捷键
1、word的F4，重复上一步操作
2、excel中 Ctrl+E 操作


###########################################################################################################################
cmake自动生成目录lib
1、对于下面的命令，cmake自动生成目录lib
	SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)


###########################################################################################################################	
思考洋葱的流程
1、考虑 select * from grade1 where chn > math; 流程是什么？
2、通过抓包发现，上面的sql语句重写为
	select `yytest`.`table_RINDNVZYLV`.`RQDCHMVSRGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltSTCMIHZRPQ`,`yytest`.`table_RINDNVZYLV`.`MDSBNIFRBHoEq`,`yytest`.`table_RINDNVZYLV`.`BVGEQNNIUDoEq`,`yytest`.`table_RINDNVZYLV`.`JBECZAOQOGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltWMPCQHRDPL` from `yytest`.`table_RINDNVZYLV` where (`yytest`.`table_RINDNVZYLV`.`MRTWUKQORQoOrder` > `yytest`.`table_RINDNVZYLV`.`GCLJSYADDKoOrder`)
3、我先思考，如果是自己做，思路是什么？
	a、要把*转化为对应的字段，一个字段扩展为多个洋葱，我使用哪一个洋葱呢？
		要选用加密过程没有信息丢失的洋葱，也就是说，可以解密的。OPE加密就会信息丢失，对于string只取前面4个字节。
		因此，这里选用eq洋葱，把*转化为每个字段的eq洋葱，因为解密还涉及到盐值，所以要select盐值字段。
	b、chn > math 涉及到两个洋葱比较，大于号决定了使用OPE洋葱，chn和math使用对应的OPE洋葱，而且要剥掉RND，OPE，到了OPE_JOIN这一层，密钥相同，就可以比较了。
		能否支持 chn > math，需要考虑哪个洋葱，以及洋葱的最里层。如下：
		const EncSet EQ_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DET, NULL)},
				{oOPE,   LevelFieldPair(SECLEVEL::OPE, NULL)},
			}
		};
		
		const EncSet JOIN_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DETJOIN, NULL)},
			}
		};
		上面是初始化的洋葱集合，以及每个洋葱的最里层。
	c、select是eq洋葱，select回来的结果，也要使用eq洋葱解密。



###########################################################################################################################
【ModernCPP_01】理解模板型别推导
1、示例代码如下：
	template<typename T>
	void f(ParamType param);
	
	f(expr);
2、先增加打印类型的代码，如下：
	#include <string>
	#include <type_traits>
	#include <typeinfo>
	#ifndef _MSC_VER
	# include <cxxabi.h>
	#endif
	#include <memory>
	#include <string>
	#include <cstdlib>	
	
	template <class T>
	std::string type_name()
	{
		typedef typename std::remove_reference<T>::type TR;
		std::unique_ptr<char, void(*)(void*)> own
			(
	#ifndef _MSC_VER
			abi::__cxa_demangle(typeid(TR).name(), nullptr,
			nullptr, nullptr),
	#else
			nullptr,
	#endif
			std::free
			);
	
		std::string r;
		if (std::is_const<TR>::value)
		{
			r +="const ";
		}		
		if (std::is_volatile<TR>::value)
		{
			r +="volatile ";
		}
		r += (own!= nullptr? own.get() : typeid(TR).name());
		if (std::is_lvalue_reference<T>::value)
		{
			r +="&";
		}
		if (std::is_rvalue_reference<T>::value)
		{
			r +="&&";
		}
	
		return r;
	}
3、考虑第一种情况，ParamType是个指针或者引用，但不是万能引用
	a、若expr具有引用型别，现将引用部分去掉
	b、然后，对expr和ParamType的型别执行模式匹配，来决定T的型别


###########################################################################################################################
CItemMath_One和CItemStrconv




###########################################################################################################################
template<class CB>
ope_domain_range
OPE::search(CB go_low)
{
    blockrng<AES> r(aesk);
/*
    return lazy_sample(to_ZZ(0), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);
                      */

   return lazy_sample(-(to_ZZ(1) << (pbits - 1)), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);

}
导致ope_join测试用例失败

###########################################################################################################################
su与sudo的再次理解



###########################################################################################################################
有一个重大的问题如下：

update导致其他的字段，发生变化，需要修改一下，先记录一下。
mysql> select * from warehouse;                       
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = 6 WHERE w_id = 1;        
Query OK, 1 row affected (0.00 sec)

mysql> select * from warehouse;                      
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 6     |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = w_ytd + 6 WHERE w_id = 1;
Query OK, 1 row affected (0.03 sec)

mysql> select * from warehouse;                              
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.00  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

w_ytd = w_ytd + 6 导致错误，需要找一下问题。
w_tax是 float存在问题，如果是int没有问题，

那我现在怎么做？
先把w_tax 不加密，来测试一把。也不行

w_ytd = 300000.00; 是写死的，因此，我使用 SET w_ytd = 6 这种方式，来设置。

INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\').....Q.#07000Error: Bad Query: [INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\')]
	Line 1736: Error Data: parse_sql


###########################################################################################################################
批量修改图片的属性
1、全选所有图片：开始－－编辑－－查找和选择－－定位条件，点选“对象”，确定；
2、右击任一图片，大小和属性，属性选项卡，点选“对象位置”中“大小和位置随单元格而变”。


###########################################################################################################################
验证流程：
1、每个测试结果点击一下，看看是否有图片显示不对。
2、修改的代码好好检查，commit，添加详细支持的log
3、自动化跑一遍
4、push代码
5、提交 FunctionTest，添加详细的log

###########################################################################################################################
配置runner ci
https://note.youdao.com/group/#/65827312/(full:pdf/201146002)




###########################################################################################################################
内存泄漏的代码好好整理一下



###########################################################################################################################
proxy failed to retrieve default database 这个问题，稍微处理一下

操作步骤
1、return tpcc注释掉，vi ../sqlhandler/rewrite/src/rewrite_util.cc 837行
2、调用rebuild_clear_all.sh
3、开启flkcdp，创建数据库 tpcc，然后关闭
4、直接return tpcc，true，然后 sudo make install
5、flkcdp >/dev/null 2>&1 
6、调用 test_load_flkcdp.sh


############################################################################################################################
1、熟练使用linux系统命令，熟悉Linux系统平台软件开发，具备Linux平台下C/C++/Python程序开发经验；
2、熟练使用C/C++，熟练掌握数据结构和算法、熟悉STL；
3、熟悉Mysql等关系型数据库产品，精通SQL语言，有数据库优化经验，优先考虑；
4、熟悉加密算法，优先考虑；
5、有良好的编码习惯，和编写高性能代码的意识；
6、具备良好的沟通技巧及团队合作精神，有工作热情，有较好的理解能力和学习能力。
############################################################################################################################





############################################################################################################################
create table staff(id int, name enc varchar(64), height enc float, weight enc float, basepay enc float, meritpay enc float, des enc varchar(128));
insert into staff value(1,"滕海明",178.5,176.25,1000.50,200.35,"I am Frank, hello");
insert into staff value(2,"陈明",170.5,150.25,900.15,310.45,"我叫陈明, 我来自上海");
insert into staff value(3,"杨万年",171.5,155.25,984.15,264.45,"我是杨万年，我是安徽人，hello");
insert into staff value(4,"刘新超",172.25,165.25,635.15,561.45,"大家好，我是刘新超");
insert into staff value(5,"钟倩",162.5,100.25,844.15,190.45,"我是钟倩，九零后");
insert into staff value(6,"倪飞",173.25,163.25,987.15,256.45,"我叫倪飞，我是安徽人");
insert into staff value(7,"牛自宾",175.5,170.25,810.15,315.45,"我是牛自宾，我来自安徽");

create database aaa;
use aaa;
create table a1(id int);
insert into a1 value(1),(2);

drop database aaa;
create database bbb;
use bbb;
create table b1(id int);
insert into b1 value(1),(2);


create database flktest;
use flktest;
create table staff(id int, name varchar(64));
insert into staff value(1,"Andy");


W0801 01:04:21.205687  6951 insert_handler.cc:48] [20180801 01:04:21.205687]aaaaa InsertHandler 150
W0801 01:04:21.205691  6951 Analysis.cc:901] [20180801 01:04:21.205690]aaaaa InsertHandler 151
W0801 01:04:21.205695  6951 Analysis.cc:915] [20180801 01:04:21.205695]aaaaa InsertHandler 1510
W0801 01:04:21.205708  6951 Analysis.cc:927] [20180801 01:04:21.205706]aaaaa InsertHandler 1511
W0801 01:04:21.205713  6951 Analysis.cc:931] [20180801 01:04:21.205711]aaaaa InsertHandler 1512
W0801 01:04:21.205715  6951 Analysis.cc:903] [20180801 01:04:21.205715]aaaaa InsertHandler 152
W0801 01:04:21.205724  6951 Analysis.cc:907] [20180801 01:04:21.205723]aaaaa InsertHandler 153
W0801 01:04:21.205729  6951 insert_handler.cc:56] [20180801 01:04:21.205727]aaaaa InsertHandler 200


W0801 01:04:50.933387  6951 insert_handler.cc:48] [20180801 01:04:50.933385]aaaaa InsertHandler 150
W0801 01:04:50.933389  6951 Analysis.cc:901] [20180801 01:04:50.933389]aaaaa InsertHandler 151
W0801 01:04:50.933393  6951 Analysis.cc:915] [20180801 01:04:50.933393]aaaaa InsertHandler 1510
W0801 01:04:50.933403  6951 Analysis.cc:927] [20180801 01:04:50.933403]aaaaa InsertHandler 1511
W0801 01:04:50.933408  6951 Analysis.cc:931] [20180801 01:04:50.933408]aaaaa InsertHandler 1512
W0801 01:04:50.933411  6951 Analysis.cc:903] [20180801 01:04:50.933411]aaaaa InsertHandler 152
W0801 01:04:50.933420  6951 Analysis.cc:907] [20180801 01:04:50.933419]aaaaa InsertHandler 153
W0801 01:04:50.933423  6951 insert_handler.cc:56] [20180801 01:04:50.933423]aaaaa InsertHandler 200


W0801 01:05:07.269625  6951 insert_handler.cc:48] [20180801 01:05:07.269624]aaaaa InsertHandler 150
W0801 01:05:07.269629  6951 Analysis.cc:901] [20180801 01:05:07.269628]aaaaa InsertHandler 151
W0801 01:05:07.269634  6951 Analysis.cc:915] [20180801 01:05:07.269633]aaaaa InsertHandler 1510
W0801 01:05:07.269645  6951 Analysis.cc:927] [20180801 01:05:07.269644]aaaaa InsertHandler 1511
W0801 01:05:07.269651  6951 Analysis.cc:931] [20180801 01:05:07.269650]aaaaa InsertHandler 1512
W0801 01:05:07.269654  6951 Analysis.cc:903] [20180801 01:05:07.269653]aaaaa InsertHandler 152
W0801 01:05:07.269665  6951 Analysis.cc:907] [20180801 01:05:07.269663]aaaaa InsertHandler 153
W0801 01:05:07.269668  6951 insert_handler.cc:56] [20180801 01:05:07.269667]aaaaa InsertHandler 200


W0801 01:21:54.518466  7311 insert_handler.cc:48] [20180801 01:21:54.518465]aaaaa InsertHandler 150
W0801 01:21:54.518471  7311 Analysis.cc:901] [20180801 01:21:54.518469]aaaaa InsertHandler 151
W0801 01:21:54.518483  7311 Analysis.cc:903] [20180801 01:21:54.518482]aaaaa InsertHandler 152
W0801 01:21:54.518492  7311 Analysis.cc:907] [20180801 01:21:54.518492]aaaaa InsertHandler 153
W0801 01:21:54.518496  7311 insert_handler.cc:56] [20180801 01:21:54.518496]aaaaa InsertHandler 200


W0801 01:22:11.590464  7308 insert_handler.cc:48] [20180801 01:22:11.590464]aaaaa InsertHandler 150
W0801 01:22:11.590468  7308 Analysis.cc:901] [20180801 01:22:11.590467]aaaaa InsertHandler 151
W0801 01:22:11.590481  7308 Analysis.cc:903] [20180801 01:22:11.590480]aaaaa InsertHandler 152
W0801 01:22:11.590490  7308 Analysis.cc:907] [20180801 01:22:11.590489]aaaaa InsertHandler 153
W0801 01:22:11.590493  7308 insert_handler.cc:56] [20180801 01:22:11.590493]aaaaa InsertHandler 200


W0801 01:22:25.222702  7308 insert_handler.cc:48] [20180801 01:22:25.222701]aaaaa InsertHandler 150
W0801 01:22:25.222705  7308 Analysis.cc:901] [20180801 01:22:25.222705]aaaaa InsertHandler 151
W0801 01:22:25.222718  7308 Analysis.cc:903] [20180801 01:22:25.222718]aaaaa InsertHandler 152
W0801 01:22:25.222728  7308 Analysis.cc:907] [20180801 01:22:25.222727]aaaaa InsertHandler 153
W0801 01:22:25.222731  7308 insert_handler.cc:56] [20180801 01:22:25.222730]aaaaa InsertHandler 200


方法调用本身的消耗
map的消耗

W0802 01:35:45.861238 14499 Cryptdb_Proxy.cc:365] [20180802 01:35:45.861227]aaaaa map begin
W0802 01:35:45.984206 14499 Cryptdb_Proxy.cc:379] [20180802 01:35:45.984143]aaaaa map end  


W0802 01:35:50.055317 14500 Cryptdb_Proxy.cc:365] [20180802 01:35:50.055306]aaaaa map begin
W0802 01:35:50.166303 14500 Cryptdb_Proxy.cc:379] [20180802 01:35:50.166274]aaaaa map end  


W0802 01:35:53.558717 14499 Cryptdb_Proxy.cc:365] [20180802 01:35:53.558706]aaaaa map begin
W0802 01:35:53.669787 14499 Cryptdb_Proxy.cc:379] [20180802 01:35:53.669758]aaaaa map end


W0802 01:38:12.773437 14733 Cryptdb_Proxy.cc:365] [20180802 01:38:12.773427]aaaaa map begin
W0802 01:38:12.837126 14733 Cryptdb_Proxy.cc:381] [20180802 01:38:12.837096]aaaaa map end  

W0802 01:38:16.437402 14732 Cryptdb_Proxy.cc:365] [20180802 01:38:16.437388]aaaaa map begin
W0802 01:38:16.505723 14732 Cryptdb_Proxy.cc:381] [20180802 01:38:16.505693]aaaaa map end  

W0802 01:38:19.927278 14733 Cryptdb_Proxy.cc:365] [20180802 01:38:19.927267]aaaaa map begin
W0802 01:38:19.989336 14733 Cryptdb_Proxy.cc:381] [20180802 01:38:19.989307]aaaaa map end




############################################################################################################################
性能测试数据
1、
	create database flktest;
	use flktest;
	create table staff(id int, name enc varchar(64));
	insert into staff value(1,"Andy");
2、目前定位到，rewrite流程：
	任何一条sql请求，rewrite流程，都会执行两个查询，
	一个是	SELECT db FROM INFORMATION_SCHEMA.PROCESSLIST  WHERE id = 59; 根据连接线程，向mysql获取当前使用的数据库， 600多微秒
	另一个是 select stale from generic_prefix_staleness where cache_id=5; 从embedded_db查询，stale值，判断当前内存与embedded_db是否同步，200多微秒	
	I0724 05:30:57.035692 13388 rewrite_util.cc:838] [20180724 05:30:57.035680]---rewrite--- bbbbb retrieveDefaultDatabase 
	I0724 05:30:57.035710 13388 rewrite_util.cc:848] [20180724 05:30:57.035709]---rewrite--- bbbbb 111 
	I0724 05:30:57.036346 13388 rewrite_util.cc:851] [20180724 05:30:57.036342]---rewrite--- bbbbb 112 
	I0724 05:30:57.036366 13388 rewrite_util.cc:863] [20180724 05:30:57.036365]---rewrite--- bbbbb retrieveDefaultDatabase 
	【int Proxy::dorewrite】
	I0724 05:30:57.036384 13388 schema.cc:615] [20180724 05:30:57.036383]---rewrite--- bbbbb lowLevelGetCurrentStaleness 
	I0724 05:30:57.036751 13388 schema.cc:630] [20180724 05:30:57.036746]---rewrite--- bbbbb lowLevelGetCurrentStaleness
	【return shared.cache.getSchema(this->getConn(), this->getEConn());】
3、next流程
	I0725 03:52:51.331641  9159 Cryptdb_Proxy.cc:959] [20180725 03:52:51.331638]---next--- ccccc begin 
	I0725 03:52:51.332839  9159 Cryptdb_Proxy.cc:961] [20180725 03:52:51.332833]---next--- ccccc end 
	I0725 03:52:51.336182  9158 Cryptdb_Proxy.cc:959] [20180725 03:52:51.336173]---next--- ccccc begin 
	I0725 03:52:51.338012  9158 Cryptdb_Proxy.cc:961] [20180725 03:52:51.338004]---next--- ccccc end 
	【genericPreamble(nparams);】
4、什么时候，得到new query
	在哪里返回的？
	
	
5、Debug信息
	error.hh
	
create database tpcc; 
use tpcc;
create table t1(id int);
	
	
	


############################################################################################################################
对嵌入式MySQL执行SQL语句
1、set @cryptdb='run', @sql='use embedded_db';

shPath=$(cd $(dirname $0);pwd)
echo $shPath

############################################################################################################################
获取系统时间，精度微秒




############################################################################################################################
find ../ -iname "*.so" |xargs ls -thl


grep "O3" ./ -Rn

############################################################################################################################
sql-bench
1、安装DBI
	cpan
	install DBI
	install DBD::mysql
2、找到下载的DBD-mysql，sudo find / -iname "DBD-mysql*"
	进入对应的目录，解压DBD-mysql
	perl Makefile.PL -testuser=root -testpassword="letmein"
	make install 
	如果报错：Cannot find the file 'mysql_config'
	执行 sudo apt-get install libmysqlclient-dev	
2、转到 mysql-src/sql-bench
	./run-all-tests.sh --server=mysql --host=127.0.0.1 --user=root --password=letmein
	./test-select.sh --server=mysql --host=127.0.0.1 --user=root --password=letmein
	./test-connect.sh --server=mysql --host=127.0.0.1 --user=root --password=letmein --connect-options=mysql_read_default_file=./my.cnf
3、Benchmark
	/usr/share/perl/5.18/Benchmark.pm
############################################################################################################################
create database flktest;
use flktest;
create table staff(id enc int, name enc varchar(64));
insert into staff value(1,"Andy"), (2,"Bill");

:
我们之前面试的 走到刘燕那一步的 有名单么
我:
没有哎
:
武俊龙 余文正 李友 施杰 邱怀宇 齐轲 洪扬 艾涛 杨智辉 朱能峰
:
余文正 洪扬 艾涛
我:
嗯，应该就是这些。
:
今天面试这两个 杨智辉 朱能峰 还不知道情况

############################################################################################################################


select sql_no_cache idn+rev_idn from bench1 where idn=5;



W0809 02:31:50.528110  6117 base_rewrite_main.cc:1028] [20180809 02:31:50.528084]aaaaa hom decrypt begin
W0809 02:31:53.808254  6117 base_rewrite_main.cc:1033] [20180809 02:31:53.808239]aaaaa hom decrypt end

W0809 02:32:00.209451  6116 base_rewrite_main.cc:1028] [20180809 02:32:00.209426]aaaaa hom decrypt begin
W0809 02:32:03.471449  6116 base_rewrite_main.cc:1033] [20180809 02:32:03.471432]aaaaa hom decrypt end

W0809 02:32:08.703430  6118 base_rewrite_main.cc:1028] [20180809 02:32:08.703404]aaaaa hom decrypt begin
W0809 02:32:11.988782  6118 base_rewrite_main.cc:1033] [20180809 02:32:11.988768]aaaaa hom decrypt end

3280155
3262006
3285364


修改HOM算法的位数，测试一把
sk = new Paillier_priv(Paillier_priv::keygen(prng.get(), nbits)); 修改为512 变成死循环，出不来了，估计还要同时修改其他的参数。


create database sql_bench;
use sql_bench;
create table bench1
(
region enc char(1) NOT NULL,idn enc integer(6) NOT NULL,rev_idn enc integer(6) NOT NULL,grp enc integer(6) NOT NULL,
primary key a (region,idn),unique b (region,rev_idn),unique c (region,grp,idn)
);

insert into bench1 value('A',100,200,300);




告诉万年，没有执行 mysql_thread_end();
            //*****************************************

            ResType res(true, 0, 0);
            return donext(client, res);






############################################################################################################################
先把原来的代码修改一下
1、去掉调试日志，默认使用release版本
2、在不加密的情况下，插入数据，然后测试select的性能消耗，测试10000次，来看消耗
3、
############################################################################################################################
测试的数据
1、插入1万条数据，每次查询语句是 select sql_no_cache idn, rev_idn from bench1 where idn=100;
2、查询5万次，比较mysql和flkcdp，每次select多消耗的时间
	mysql：
	test select[select sql_no_cache idn, rev_idn from bench1 where idn=100] 
	Time to select (50000): 46 wallclock secs ( 1.48 usr +  0.29 sys =  1.77 CPU)
	
	flkcdp：
	test select[select sql_no_cache idn, rev_idn from bench1 where idn=100] 
	Time to select (50000): 71 wallclock secs ( 0.37 usr +  2.96 sys =  3.33 CPU)
	
	每一次select多消耗的时间是 (71-46)*1000000/50000 = 500微秒，也就是说，每一次select，流程上的消耗是500微秒	
3、确认消耗时间的瓶颈，注意我们的release带有debug信息，只是进行了O3优化
	这500微秒消耗在哪里？
	Rewriter::rewrite
	W0809 23:32:40.834921 16593 Cryptdb_Proxy.cc:389] [20180809 23:32:40.834907]aaaaa 100
	W0809 23:32:41.815474 16593 Cryptdb_Proxy.cc:394] [20180809 23:32:41.815462]aaaaa 200
	
	W0809 23:32:45.490936 16592 Cryptdb_Proxy.cc:389] [20180809 23:32:45.490926]aaaaa 100
	W0809 23:32:46.464092 16592 Cryptdb_Proxy.cc:394] [20180809 23:32:46.464079]aaaaa 200
	
	W0809 23:32:49.797080 16592 Cryptdb_Proxy.cc:389] [20180809 23:32:49.797065]aaaaa 100
	W0809 23:32:50.756587 16592 Cryptdb_Proxy.cc:394] [20180809 23:32:50.756576]aaaaa 200
	
	980555 + 973153 + 959511 = 971073 / 10000 = 97 微秒	
	
	还有其他的开销在哪里？
	
	
	
	
W0809 23:55:14.146692 19130 Cryptdb_Proxy.cc:389] [20180809 23:55:14.146682]aaaaa 100
W0809 23:55:15.191277 19130 Cryptdb_Proxy.cc:394] [20180809 23:55:15.191262]aaaaa 200
W0809 23:55:15.191814 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:15.191808]aaaaa 300
W0809 23:55:15.192049 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:15.192043]aaaaa 400
W0809 23:55:15.194294 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:15.194286]aaaaa 300
W0809 23:55:15.194571 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:15.194564]aaaaa 400


W0809 23:55:19.186285 19130 Cryptdb_Proxy.cc:389] [20180809 23:55:19.186276]aaaaa 100
W0809 23:55:20.272120 19130 Cryptdb_Proxy.cc:394] [20180809 23:55:20.272108]aaaaa 200
W0809 23:55:20.272591 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:20.272587]aaaaa 300
W0809 23:55:20.272758 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:20.272754]aaaaa 400
W0809 23:55:20.274210 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:20.274205]aaaaa 300
W0809 23:55:20.274444 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:20.274440]aaaaa 400


W0809 23:55:23.668009 19130 Cryptdb_Proxy.cc:389] [20180809 23:55:23.668000]aaaaa 100
W0809 23:55:24.698678 19130 Cryptdb_Proxy.cc:394] [20180809 23:55:24.698663]aaaaa 200
W0809 23:55:24.699545 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:24.699500]aaaaa 300
W0809 23:55:24.699802 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:24.699799]aaaaa 400
W0809 23:55:24.701290 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:24.701284]aaaaa 300
W0809 23:55:24.701552 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:24.701548]aaaaa 400


############################################################################################################################
站在领导的角度，看看自己做了什么工作
1. 熟悉并使用perl语言实现的性能测试工具sql-bench，进行select语句的基准测试，对照mysql和flkcdp
2. select性能问题，进行优化后，目前flkcdp一次select相对于mysql多消耗500微秒，这500毫秒主要包括：
   增加一层代理的网络开销，改写sql语句的开销，处理select结果的开销，代码层面可以优化的空间已经比较小。
   因此相对于mysql的性能，取决于这固定的500微秒在整个select流程的比重，在mysql没有开启查询缓存，性能达到mysql的40%左右，一旦mysql开启查询缓存，性能相差非常大。
   初步的解决思路是，在配置文件增加选项，处理流程中，对于重复出现的数据进行缓存，在命中率很高的情况下，大大提高性能。
3. 给出加解密算法对于性能影响的分析，目前HOM（同态加减乘除）加解密耗时300微秒，OPE（同态大小比较）加解密，明文数字小耗时300微秒，当加密的数字很大，性能严重下降，
   DET（同态相等）不构成瓶颈，因此对于select，查询回来的记录，解密开销成为瓶颈。特别是查询回来的记录个数很多，全部解密，性能严重下降。
   目前加解密的算法开销，比较难优化，除非牺牲一定的安全性。初步的解决思路也是，进行缓存，缓存明文密文的映射关系。
4. 对接了销帮帮，了解到其使用的Elasticsearch技术，并进行了预研，和我们的使用场景差别比较大，还需要进一步和销帮帮沟通，最后确认初步的方案。
5. 解决JDBC代码覆盖率的问题，并整理出来issue
6. FLKCDP进行了流程优化，JDBC的代码进行接口调整修改
7. 新入职和转入员工的环境搭建和熟悉。
############################################################################################################################
void GetSystemTime(timeval& tv)
{
    gettimeofday(&tv,NULL);
}

double SubSystemTime(const timeval& begin, const timeval& end)
{
    return (end.tv_sec - begin.tv_sec) + (double)(end.tv_usec - begin.tv_usec)/(1000000.0);
}

############################################################################################################################
1、基准测试，需要测试的情况
	a、计算一下void   GetSystemTime(timeval& tv); 本身的耗时，本身耗时 0.17微秒，因此可以忽略不计
	b、对于没有副作用的函数，直接调用多次，统计每次的耗时
	c、对于有副作用的函数，客户端执行多次，在达到多次的情况下，统计一下耗时
2、
static int rewrite 156微秒
static int next    54微秒

    /*
    static int count = 0;
    static int sum = 0;
    timeval begin;
    FLKCDP::GetSystemTime(begin);
    timeval end;
    */

    ANON_REGION(__func__, &perf_cg);
    scoped_lock l(&big_lock);
    mysqlProxy<lua_State> nextObj(L);
    std::string client;
    const ResType &res = nextObj.getnextArg(client);

    int ret = nextObj.donext(client, res);

    /*
    FLKCDP::GetSystemTime(end);
    sum += FLKCDP::SubSystemTime(begin,end);
    if(count%10000 == 0)
    {
        LOG(WARNING)<<"rewrite time["<< sum <<"]";
        sum = 0;
    }
    ++count;
    */

timeval begin;
FLKCDP::GetSystemTime(begin);
for(int i =0; i<10000; ++i)
{
    std::unique_ptr<QueryRewrite> qr = std::unique_ptr<QueryRewrite>(new QueryRewrite(Rewriter::rewrite(query, *schema.get(), c_wrapper->default_db, *ps)));
}
timeval end;
FLKCDP::GetSystemTime(end);
LOG(WARNING)<<"Rewriter::rewrite["<< FLKCDP::SubSystemTime(begin,end) <<"]";

############################################################################################################################
优化的处理
1、保存原始sql语句对应的改写sql语句，在什么地方添加，整个流程走完，才添加。
2、知道怎么解密，他是next流程来的，只有结果，和client，我怎么找到

############################################################################################################################
北京石景山区保障房中心

drop database flktest;
create database flktest;
use flktest;
create table staff(id int, name varchar(64));
insert into staff value(1,"Andy"),(2,"Bill"),(3,"Caroline");

select * from staff where id=2;

############################################################################################################################
修改的内容
加上日志
static LogClassInit l;


strncasecmp 直接写死，提高性能
改成 newRes

                const auto &res = new_results.second->extract<ResType>();
                ret = setResResults(res);
                if(new_results.second)
                {
                    delete new_results.second;
                }

sleep立即去掉
            LOG(INFO)<<"Check License failed";
            sleep(10);
############################################################################################################################
1、对查询语句缓存，把rewrite流程【改写sql】的时间开销，全部节省下来，现在达到查询一万次（不考虑加解密的瓶颈），耗时2.6秒，
	2.6秒消耗，2.1秒在多一层代理的时间开销。
2、
############################################################################################################################
DBI和DBD
1、DBI是DB interface
2、DBD是DB Driver，包括mysql、oracle等
############################################################################################################################
perl mysql绑定变量
1、

create database yytest;
use yytest;
create table staff(id int, name varchar(64));
insert into staff value(1,"Andy"), (2,"Bill");

select * from staff;





my $sth = $dbh ->prepare('select * from staff where id = ?'); 
my @ids = qw/1 2 3 4 5/;
 
foreach my $id (@ids) 
{
    $sth->execute($id);  
    print "\$sth is $sth\n";
	while (my  @arr = $sth->fetchrow_array())
	{
	    print "@arr\n";
    }
}




http://outofmemory.cn/code-snippet/2798/Perl-call-MySQL-cunchuguocheng-get-fanhuizhi



############################################################################################################################
qw
1、qw(100 200 300); 或者 qw/100 200 300/; 等价于 ('100','200','300'); 如下：
	#!/usr/bin/perl
	
	#@arr = (100,200,300);
	#@arr = ('100','200','300');
	#@arr = qw(100 200 300);
	@arr = qw/100 200 300/;
	
	foreach my $a (@arr)
	{
		print "$a\n";
	}
############################################################################################################################
JDBC绑定变量
1、需要设置 useServerPrepStmts=true&cachePrepStmts=true



############################################################################################################################
理解协程
1、考虑下面的需求，一个任务分为3个步骤来做，每个步骤会分配一个线程来处理，这个线程是根据调度算法从线程池中分配出来的。
2、在工作中的两个项目中都碰到这个问题。第一个项目的解决方案是，任务移动，基于Msg，这个消息是包含任务的具体内容。
	先把任务push给线程A，当这个线程处理完毕，然后push给线程B，然后push给线程C
3、第二个项目的解决方案是，使用协程，任务不动，分为3个步骤，进来一个线程处理第一步，再来一个线程处理第二步，再来另外一个线程处理第三步。
	每次做完一个步骤，交出控制权。
4、协程是怎么做到每个线程做一个步骤的？
	可以简单理解为 switch case，每次switch进入case之后，对象的字段值加1，下一次进来，就会从下一个case继续执行。	


查询语句的流程和时间消耗
1、SQL语句--->lex-->拷贝lex为newlex-->遍历newlex的属性，然后修改-->


############################################################################################################################
extern
1、extern置于变量或者函数前，表示变量或者函数的定义在别的文件中。
	编译的时候，能够正常使用，可理解为占位符，但是链接的时候，会尝试从其它模块中寻找其定义。
2、如果使用extern，但是又定义了，比如extern int a = 5; 编译会有告警，这个时候的效果，就是定义。
3、一个源文件中的全局对象，编译成模块后，都会暴露出来，其它模块在链接的时候，可以定位到。
	如果我不想让其它模块链接，怎么办？ 使用static修饰，表示内部链接性，不暴露出来。	
############################################################################################################################
代码逻辑的测试
1、

create table student(id enc int, name enc varchar(64));
insert into student(id, name) value(1,"Andy"),(2,"Bill"),(3,"Caroline"),(4,"David");
create table teacher(id enc int, name enc varchar(64));
insert into teacher(id, name) value(1,"Mr Li"),(2,"Ms Wang"),(3,"Mr Zhang"),(4,"Mr He");
create table grade(id enc int, name enc varchar(64), stuid enc int, teaid enc int, score enc int);
insert into grade(id,name,stuid,teaid,score) value(1,"Math",1,2,85),(2,"Math",2,2,86),(3,"Math",3,2,87),(4,"Math",4,2,88),(5,"Math",5,2,89),(6,"Math",6,2,90);



select * from student;


select S.name from student as S;



select student.name, G.score from student inner join grade as G on student.id = G.stuid;


select * from (select * from student where id >1) as S where S.name="Bill";






select S.id, S.name from student as S;


select * from student;



select id from student;

select min()



两者的差别：

select name from student where id > 2;
走到字段比较

select student.name, grade.name from student,grade where student.id = grade.stuid;
走到function比较






select * from student order by id desc;



select student.name, G.score from student inner join grade as G on student.id = G.stuid;

select student.name, G.score from student,grade as G where student.id = G.stuid;





create table student(id int, name varchar(64));
insert into student(id, name) value(1,"Andy"),(2,"Bill"),(3,"Caroline"),(4,"David");
create table teacher(id int, name varchar(64));
insert into teacher(id, name) value(1,"Mr Li"),(2,"Ms Wang"),(3,"Mr Zhang"),(4,"Mr He");
create table grade(id int, name varchar(64), stuid int, teaid int, score int);
insert into grade(id,name,stuid,teaid,score) value(1,"Math",1,2,85),(2,"Math",2,2,86),(3,"Math",3,2,87),(4,"Math",4,2,88),(5,"Math",5,2,89),(6,"Math",6,2,90);



############################################################################################################################
类模板和模板类，实例化，特化
1、类模板，重心是模板，模板有类的模板和方法的模板。
2、模板类，重心是类，是一种特殊的类，根据类的模板，实例化出来的一种类。
3、什么是实例化？
	根据类模板，指定模板参数，产生一个类，就是实例化。
4、什么是特化？
	考虑解决什么问题？有了模板，指定模板参数，就能产生对应的模板类或者模板方法，这带来一个问题，实例化出来的，行为都是一致的。
	有时候这不是我们预期的，我们会有这种需求，对于大部分类型，我们期望产生这样的实例化，但是对于某种特殊的类型，我们期望使用另一种实例化。
	比方说，方法模板，求两个对象的最大值，调用>操作，对于数值类型（int、float）实例化出来是OK的，但是对于string，实例化出来的结果，不是我们所预期的。
	对于string，求最大值，我们期望是忽略大小写，逐个字符比较。因此，对于这种情况，我们期望有一个特殊的模板，这就是原来模板的特化。
	特化也就是说，一个模板对付大多数类型的实例化，但是对于某个特殊的类型，单独构造一个模板，用于实例化这个特殊的类型。
5、特化分为全特化和偏特化，模板往往有多个参数，所有的参数都限定死，就是全特化。部分参数限定死，就是偏特化。
	判断是不是模板的关键是看，是否还存在不确定的模板参数。偏特化还是模板，全特化已经不是模板了。
	全特化的作用是，优先匹配某种特殊的类型，防止使用默认的模板来实例化。
############################################################################################################################
1、CItemType是个普通类
2、CItemSubtype继承CItemType，是个类的模板，模板参数是 do_gather_type(static_cast<const T &>(i), a); 
3、CItemSubtypeFT是
   
   





