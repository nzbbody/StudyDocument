###########################################################################################################################
如何测试embed_tool
1、先清空shadow目录和远端mysql中的数据库
2、启动proxy，调用测试脚本，生成shadow目录
3、把【1】中的aaa目录清空，scp拷贝shadow过去，导出aaa.sql文件。
4、导出xml文件，清空shadow_2，导入shadow_2
5、把【1】中的aaa目录清空，scp拷贝shadow过去，导出bbb.sql文件。
6、对照一把sql文件
7、使用shadow进行测试
8、然后再使用shadow_2测试
	

###########################################################################################################################
密码学有关
密码学6个重要工具：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器

###########################################################################################################################
https不可用
1、https不可用
	niuzibin@ubuntu:~/work/FLKDBEnc$ sudo git clone https://192.168.10.99/FLKDBEnc/FLKWebCrypt
	Cloning into 'FLKWebCrypt'...
	fatal: unable to access 'https://192.168.10.99/FLKDBEnc/FLKWebCrypt/': gnutls_handshake() failed: Handshake failed
2、使用git@方式
	https://192.168.10.99/profile/keys
	找到generate it
	本地执行 
	ssh-keygen -t rsa -C "niuzibin@flksec.com"
	cat ~/.ssh/id_rsa.pub
3、产生的结果拷贝到 Key，然后add
4、本地执行 git clone git@192.168.10.99:FLKDBEnc/FLKWebCrypt.git	
###########################################################################################################################
CLion缺少库，需要export怎么办？
1、CLion报错，could not find java
2、加上export就可以了，但是在CLion不知道在哪里添加
3、换一种思路，在 .bashrc增加export，然后在shell脚本中，执行 source .bashrc
	进入clion的执行路径，执行
	/home/niuzibin/work/apps/clion-2016.1.1/bin/clion.sh

###########################################################################################################################
kms密钥管理服务器
1、kms是密钥管理服务器，需要向kms获取密钥，是否支持用户设置？
2、要向kms获取密钥，需要一组参数，这组参数确定密钥
3、客户端和kms交互，需要会话密钥，这就涉及密钥配送的问题，解决这个问题，使用公钥密码，向服务端请求公钥。
4、客户端请求，使用服务端的公钥SM2，对会话密钥加密。
5、考虑到会话密钥的


3、获取过程是经过网络的，如果请求是明文，第三方可以截取到，存在风险。
4、怎么解决？
	客户端的请求要加密，服务端先传一个公钥。
5、服务端传输的密钥，也需要加密
	需要客户端传输密钥
6、
	
	
###########################################################################################################################
wiki编辑
1、添加主题
	http://192.168.10.70/doku.php?id=sidebar

###########################################################################################################################
重要的错误
安装sudo apt install libmysqld-dev
导致assert(0 == mysql_thread_init());//初始化线程环境，断言失败



###########################################################################################################################
同时生成静态库和动态库



###########################################################################################################################
merge
1、如果没有分叉，从dev合并，就是 Fast-forward
2、本地合并，存在冲突。
	
###########################################################################################################################
origin
1、origin是个远程地址，通过下面的语句可以看到
	root@ubuntu:/home/disk1/GitTest# git remote -v
	origin  https://github.com/nzbbody/GitTest (fetch)
	origin  https://github.com/nzbbody/GitTest (push)



###########################################################################################################################
ope join
create database yytest;
------------------------------------------------------------------------------------------------------------
use yytest;
drop if exists table course;
create table course(id enc int, name enc varchar(64), chinese enc int, `math` enc int, english enc int);
insert into course(id,name,chinese,math,english) value(1,"Andy", 70,80,90);
insert into course(id,name,chinese,math,english) value(1,"Bill", 74,74,70);
insert into course(id,name,chinese,math,english) value(1,"Caroline", 80,85,89);
insert into course(id,name,chinese,math,english) value(1,"David", 80,75,74);
insert into course(id,name,chinese,math,english) value(1,"Eric", 79,76,84);
insert into course(id,name,chinese,math,english) value(1,"Frank", 85,72,73);
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
use yytest;
drop if exists table course2;
create table course2(id enc int, name enc varchar(64), chinese enc int, `math` enc int, english enc int);
insert into course2(id,name,chinese,math,english) value(1,"Andy", 68,80,90);
insert into course2(id,name,chinese,math,english) value(1,"Bill", 75,71,70);
insert into course2(id,name,chinese,math,english) value(1,"Caroline", 81,85,89);
insert into course2(id,name,chinese,math,english) value(1,"David", 81,75,74);
insert into course2(id,name,chinese,math,english) value(1,"Eric", 80,76,84);
insert into course2(id,name,chinese,math,english) value(1,"Frank", 86,72,73);
------------------------------------------------------------------------------------------------------------


select course.*, course2.* from course, course2 where course.name > course2.name and course.chinese > course2.chinese;


select * from course;
select * from course where chinese > 75;

UPDATE `yytest`.table_PTKLRHEBIO    SET BIYJSNVOVGoOrder = cast(cryptdb_decrypt_int_sem(`yytest`.`table_PTKLRHEBIO`.`BIYJSNVOVGoOrder` AS `BIYJSNVOVGoOrder`,'.SO\Z..>.s{^[....',`yytest`.`table_PTKLRHEBIO`.`cdb_saltOZVHWSXTKN` AS `cdb_saltOZVHWSXTKN`) as unsigned);

select * from course where chinese = math;

select * from course where chinese > math;
思考，在哪里剥的洋葱？


OPE存在的问题
1、目前的OPE只支持 select * from course where chinese > 75;
	不支持 select * from course where chinese > math;
	也就是说，支持和常数的比较，不支持和其他字段的比较。
2、为什么？
	要支持OPE操作，必须使用的密钥相同，如果不相同肯定不行。
	目前不同字段OPE算法的密钥是不同的，产生密钥使用seedkey和扩展的字段名（这个是随机的），
	如果要支持不同字段的OPE操作，字段名这个参数必须相同。
3、但是这样就不安全了，支持OPE的不同字段，使用相同的参数，产生相同的密钥。
4、cryptdb有可能是故意不支持的。
5、支持的功能和安全性相互冲突，必须找到一个平衡点。



考虑不同表？

create table t1(id enc int);

select cryptdb_decrypt_int_ope(GAAAROSNIEoOrder,'111',cdb_saltGYIIPPWTGJ) from table_KJSSJVNTFI;


###########################################################################################################################
git fetch pull push再去了解一下


###########################################################################################################################
diff命令
1、diff比较分支，必须是已经提交的分支
2、merge只能是merge，提交的分支




###########################################################################################################################
加密模式的区别
1、SENSITIVE等级最高，BEST_EFFORT相对于SENSITIVE，只是多了一个洋葱，支持剥到明文，PLAIN就是明文。
2、BEST_EFFORT和SENSITIVE，会根据实际需要配置洋葱层，在使用的过程中，为了支持，会剥掉洋葱。





###########################################################################################################################
DETJOINFactory 和 DETFactory 什么区别？
std::unique_ptr<EncLayer>
DETFactory::create(const Create_field &cf, const std::string &key)
{
    if (isMySQLTypeNumeric(cf)) {
        if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            FAIL_TextMessageError("decimal support is broken");
        } else {
            return std::unique_ptr<EncLayer>(new DET_int(cf, key));
        }
    } else {
        return std::unique_ptr<EncLayer>(new DET_str(cf, key));
    }
}

std::unique_ptr<EncLayer>
DETFactory::deserialize(unsigned int id, const SerialLayer &sl)
{
    if ("DET_int" == sl.name) {
        return DET_abstract_integer::deserialize<DET_int>(id,
                                                       sl.layer_info);
    } else if ("DET_dec" == sl.name) {
        FAIL_TextMessageError("decimal support broken");
    } else if ("DET_str" == sl.name) {
        return std::unique_ptr<EncLayer>(new DET_str(id, sl.layer_info));
    } else {
        FAIL_TextMessageError("Unknown type for DET deserialization!");
    }
}

###########################################################################################################################
MySQL的UDF
1、MySQL的UDF(user-defined function)，用户自定义函数，

好好搞一下 base64_encode 弄一下







###########################################################################################################################
ope join
create database yytest;
------------------------------------------------------------------------------------------------------------
use yytest;


create table grade1(id enc int, name enc varchar(64), chn enc int, `math` enc int);
insert into grade1(id,name,chn,math) value(1,"Andy", 70,75);
insert into grade1(id,name,chn,math) value(2,"Bill", 75,74);
insert into grade1(id,name,chn,math) value(3,"Caroline", 80,78);
insert into grade1(id,name,chn,math) value(4,"David", 85,90);


create table grade2(id enc int, name enc varchar(64), chn enc int, `math` enc int);
insert into grade2(id,name,chn,math) value(1,"Andy", 72,73);
insert into grade2(id,name,chn,math) value(2,"Bill", 78,72);
insert into grade2(id,name,chn,math) value(3,"Caroline", 76,90);
insert into grade2(id,name,chn,math) value(4,"David", 88,76);



create table grade3(id enc int, name enc varchar(64), lastname enc varchar(64),chn enc int, `math` enc int);
insert into grade3(id,name,lastname,chn,math) value(1,"Andy", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(2,"Bill", "James",75,74);
insert into grade3(id,name,lastname,chn,math) value(3,"Caroline", "Onil",80,78);
insert into grade3(id,name,lastname,chn,math) value(4,"David", "Bill",85,90);
insert into grade3(id,name,lastname,chn,math) value(5,"Andy1", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(6,"Andy2", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(7,"Andy3", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(8,"Andy4", "Green",70,75);



select * from grade3 where lastname > name;


###########################################################################################################################
OPE剥洋葱的细节
1、varbinary当成varchar使用
2、RND剥洋葱涉及到salt，其它的剥洋葱不涉及
3、由于加上了OPEJOIN，也就是 【【【OPEJOIN】OPE】RND】
	这就要剥洋葱 OPE， RND剥掉之后，就需要剥掉OPE，秘钥不同
4、为什么不需要 OPE_str::decryptUDF ？
	static onionlayout STR_ONION_LAYOUT = 
	{
    {oDET, std::vector<SECLEVEL>({SECLEVEL::DETJOIN, SECLEVEL::DET,
                                  SECLEVEL::RND})},
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
    {oSWP, std::vector<SECLEVEL>({SECLEVEL::SEARCH})}
    // {oSWP, std::vector<SECLEVEL>({SECLEVEL::PLAINVAL, SECLEVEL::DET,
                                  // SECLEVEL::RND})}
	};
	因为string的OPE是 {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
	string--OPEJOIN-->int--OPE-->int， 这里的OPE是对int处理，所以剥掉的也是OPE_int
5、对于string的OPE操作，只能比较前面4个字节，为什么？
	因为OPE算法只对前面4个字节，加密，加密的结果是 varbinary(32), 32个字节。
6、为什么只对前面4个字节加密？
	因为string的长度是不确定的，没有办法支持加密后的结果进行OPE比较。
7、为什么对前面4个字节加密，select出来的结果，是完整的？
	因为select的是eq这个洋葱，作为判断使用的是ope洋葱。
###########################################################################################################################	
mysql的varbinary
1、select出来varbinary看到的值不是字节的值，而是字节的ASCCI值。如下：
	CREATE TABLE test1 (c1 VARBINARY(3));
	INSERT INTO test1 set c1 = 0x61;
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	+----+
	1 row in set
2、再添加一个记录，如下：
	mysql> INSERT INTO test1 set c1 = 0x31;
	Query OK, 1 row affected
	
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	| 1  |
	+----+
	2 rows in set
	注意：这里的1是ASCCI值，取值为49
###########################################################################################################################
快捷键
1、word的F4，重复上一步操作
2、excel中 Ctrl+E 操作

###########################################################################################################################
16.4 安装gitlab
不行就手动安装
手动安装已经OK

###########################################################################################################################
cmake自动生成目录lib
1、对于下面的命令，cmake自动生成目录lib
	SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)


###########################################################################################################################
chmod的区别
1、比较 【sudo chmod 777 ./* -R】 和 【sudo chmod 777 ./ -R】，如下：
	niuzibin@ubuntu:~/111/ccc$ sudo chmod 777 ./* -R
	niuzibin@ubuntu:~/111/ccc$ ll
	total 8
	drwxrwxr-x 2 niuzibin niuzibin 4096 Jun 14 11:22 ./
	drwxrwxr-x 4 niuzibin niuzibin 4096 Jun 14 11:22 ../
	-rwxrwxrwx 1 niuzibin niuzibin    0 Jun 14 11:22 aaa*
	niuzibin@ubuntu:~/111/ccc$ sudo chmod 777 ./ -R 
	niuzibin@ubuntu:~/111/ccc$ ll
	total 8
	drwxrwxrwx 2 niuzibin niuzibin 4096 Jun 14 11:22 ./
	drwxrwxr-x 4 niuzibin niuzibin 4096 Jun 14 11:22 ../
	-rwxrwxrwx 1 niuzibin niuzibin    0 Jun 14 11:22 aaa*
2、也就是说，sudo chmod 777 ./* -R 不能改变当前目录的权限

###########################################################################################################################	
itemTypes.reg(Item::Type::FUNC_ITEM, *this);
在这里注册


###########################################################################################################################	
clion使用很卡
1、设置一下
	File --> Settings --> Editor --> General --> Code Completion 取消掉
	File --> Settings --> Editor --> General --> Inspections C/C++取消掉
2、取消Power Save Mode
	找到右下角的人头，设置设置 Highlighting Level到最低
###########################################################################################################################	
思考洋葱的流程
1、考虑 select * from grade1 where chn > math; 流程是什么？
2、通过抓包发现，上面的sql语句重写为
	select `yytest`.`table_RINDNVZYLV`.`RQDCHMVSRGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltSTCMIHZRPQ`,`yytest`.`table_RINDNVZYLV`.`MDSBNIFRBHoEq`,`yytest`.`table_RINDNVZYLV`.`BVGEQNNIUDoEq`,`yytest`.`table_RINDNVZYLV`.`JBECZAOQOGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltWMPCQHRDPL` from `yytest`.`table_RINDNVZYLV` where (`yytest`.`table_RINDNVZYLV`.`MRTWUKQORQoOrder` > `yytest`.`table_RINDNVZYLV`.`GCLJSYADDKoOrder`)
3、我先思考，如果是自己做，思路是什么？
	a、要把*转化为对应的字段，一个字段扩展为多个洋葱，我使用哪一个洋葱呢？
		要选用加密过程没有信息丢失的洋葱，也就是说，可以解密的。OPE加密就会信息丢失，对于string只取前面4个字节。
		因此，这里选用eq洋葱，把*转化为每个字段的eq洋葱，因为解密还涉及到盐值，所以要select盐值字段。
	b、chn > math 涉及到两个洋葱比较，大于号决定了使用OPE洋葱，chn和math使用对应的OPE洋葱，而且要剥掉RND，OPE，到了OPE_JOIN这一层，密钥相同，就可以比较了。
		能否支持 chn > math，需要考虑哪个洋葱，以及洋葱的最里层。如下：
		const EncSet EQ_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DET, NULL)},
				{oOPE,   LevelFieldPair(SECLEVEL::OPE, NULL)},
			}
		};
		
		const EncSet JOIN_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DETJOIN, NULL)},
			}
		};
		上面是初始化的洋葱集合，以及每个洋葱的最里层。
	c、select是eq洋葱，select回来的结果，也要使用eq洋葱解密。
###########################################################################################################################	
思考洋葱的流程
1、思考
	select name from grade1; 和 select upper(name) from grade1; 是如何选择洋葱的？
	找到这个关键方法，return lookup(i).do_gather(i, a);
	--> class CItemStrconv : public CItemSubtypeFN<Item_str_conv, NAME>
	--> RewritePlan * do_gather_type
	--> typical_gather_string
###########################################################################################################################	
move与forward学习
1、一定要学习好





###########################################################################################################################
【ModernCPP_01】理解模板型别推导
1、示例代码如下：
	template<typename T>
	void f(ParamType param);
	
	f(expr);
2、先增加打印类型的代码，如下：
	#include <string>
	#include <type_traits>
	#include <typeinfo>
	#ifndef _MSC_VER
	# include <cxxabi.h>
	#endif
	#include <memory>
	#include <string>
	#include <cstdlib>	
	
	template <class T>
	std::string type_name()
	{
		typedef typename std::remove_reference<T>::type TR;
		std::unique_ptr<char, void(*)(void*)> own
			(
	#ifndef _MSC_VER
			abi::__cxa_demangle(typeid(TR).name(), nullptr,
			nullptr, nullptr),
	#else
			nullptr,
	#endif
			std::free
			);
	
		std::string r;
		if (std::is_const<TR>::value)
		{
			r +="const ";
		}		
		if (std::is_volatile<TR>::value)
		{
			r +="volatile ";
		}
		r += (own!= nullptr? own.get() : typeid(TR).name());
		if (std::is_lvalue_reference<T>::value)
		{
			r +="&";
		}
		if (std::is_rvalue_reference<T>::value)
		{
			r +="&&";
		}
	
		return r;
	}
3、考虑第一种情况，ParamType是个指针或者引用，但不是万能引用
	a、若expr具有引用型别，现将引用部分去掉
	b、然后，对expr和ParamType的型别执行模式匹配，来决定T的型别
	



###########################################################################################################################
CItemMath_One和CItemStrconv








###########################################################################################################################
template<class CB>
ope_domain_range
OPE::search(CB go_low)
{
    blockrng<AES> r(aesk);
/*
    return lazy_sample(to_ZZ(0), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);
                      */

   return lazy_sample(-(to_ZZ(1) << (pbits - 1)), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);

}
导致ope_join测试用例失败
###########################################################################################################################
目前确认不支持的
1、方法中是个表达式
	select floor(id+1) from grade1;
2、方法的嵌套
	select floor(sin(id)) from grade1;
3、两个参数、三个参数、参数不确定
	
4、


###########################################################################################################################
ope_join测试用例失败的原因分析
1、cmake 静态库的代码修改，动态库 make 没有重新链接，必须先要make clean一下
2、动态库edb.so修改了，安装到mysql服务，必须重启一下mysql服务
3、也就是会出现：
	没有clean，没有重启mysql，测试OK
	clean，并且重启mysql，测试OK
4、ope_join测试用例失败的原因找到了，：杨万年修改了ope的算法，静态库libedbcrypto_static.a发生变化，生成的edb.so的时候，先clean，再make
	edb.so变化，并且注册到mysql服务，但是没有重启mysql服务，导致剥洋葱的update操作失败。	
	另外还存在一个camek的问题，大家注意一下，动态库 a.so 链接静态库 b.a， 静态库b.a代码修改，重新编译， 生成动态库a.so时候，必须clean一下，否则a.so不会更新。	
	有些人的本地，没有重启mysql服务，ope_join测试也是成功的，原因是 生成edb.so的时候，没有clean，实际上一直没有更新edb.so



###########################################################################################################################
su与sudo的再次理解







###########################################################################################################################
tpcc-mysql的性能测试
1、下载源码，构建
	git clone https://github.com/Percona-Lab/tpcc-mysql.git
	进入tpcc-mysql/src目录，执行make构建，生成tpcc_load和tpcc_start可执行文件，说明构建OK
2、准备工作
	a、创建数据库  
	mysqladmin create tpcc1000 -h127.0.0.1 -P3306 -uroot -pletmein 
	b、创建相应数据表  
	mysql tpcc1000 -h127.0.0.1 -P3306 -uroot -pletmein < create_table.sql  
	c、创建索引  
	mysql tpcc1000 -h127.0.0.1 -P3306 -uroot -pletmein < add_fkey_idx.sql  	
	d、装载数据  
	./tpcc_load -h127.0.0.1 -P3306 -dtpcc1000 -uroot -pletmein -w 1 
3、执行测试
	./tpcc_start -h127.0.0.1 -P3306 -dtpcc1000 -uroot -p123321 -w1 -c32 -r10 -l60
	选项解释如下：
	-w 指定仓库数量
	-c 指定并发连接数
	-r 指定开始测试前进行warmup的时间，进行预热后，测试效果更好
	-l 指定测试持续时间
	-i  指定生成报告间隔时长
	-f 指定生成的报告文件名
	也可以生成文件如下： 
	./tpcc_start -h127.0.0.1 -P3306 -dtpcc1000 -uroot -w1 -c32 -r10 -l60 -f tpcc_mysql_20180617.log > tpcc_caseX_20180617.log 2>&1
4、表的业务逻辑
	New-Order：新订单，主要对应 new_orders 表
	Payment：支付，主要对应 orders、history 表
	Order-Status：订单状态，主要对应 orders、order_line 表
	Delivery：发货，主要对应 order_line 表
	Stock-Level：库存，主要对应 stock 表
	
	其他相关表：
	客户：主要对应 customer 表
	地区：主要对应 district 表
	商品：主要对应 item 表
	仓库：主要对应 warehouse 表
5、报告分析
***************************************
*** ###easy### TPC-C Load Generator ***
***************************************
option h with value '1.2.3.4'   -- 主机
option P with value '3306'             -- 端口
option d with value 'tpcc10'         -- 数据库
option u with value 'tpcc'             -- 账号
option p with value 'tpcc'             -- 密码
option w with value '10'                 -- 仓库数
option c with value '64'                 -- 并发线程数
option r with value '30'                 -- 数据预热时长
option l with value '120'               -- 压测时长
option f with value 'tpcclog_20140921_64_THREADS.res'  -- 输出报告日志文件

     [server]: 1.2.3.4
     [port]: 3306
     [DBname]: tpcc10
       [user]: tpcc
       [pass]: tpcc
  [warehouse]: 10
 [connection]: 64
     [rampup]: 30 (sec.)
    [measure]: 120 (sec.)

RAMP-UP TIME.(30 sec.)

-- 预热结束，开始进行压测
MEASURING START.

-- 每10秒钟输出一次压测数据
  10, 8376(0):2.744|3.211, 8374(0):0.523|1.626, 838(0):0.250|0.305, 837(0):3.241|3.518, 839(0):9.086|10.676
  20, 8294(0):2.175|2.327, 8292(0):0.420|0.495, 829(0):0.206|0.243, 827(0):2.489|2.593, 827(0):7.214|7.646
…
 110, 8800(0):2.149|2.458, 8792(0):0.424|0.710, 879(0):0.207|0.244, 878(0):2.461|2.556, 878(0):7.042|7.341
 120, 8819(0):2.147|2.327, 8820(0):0.424|0.568, 882(0):0.208|0.237, 881(0):2.483|2.561, 883(0):7.025|7.405
-- 以逗号分隔，共6列
-- 第一列，第N次10秒
-- 第二列，总成功执行压测的次数(总推迟执行压测的次数):90%事务的响应时间|本轮测试最大响应时间
-- 第三列，新订单业务成功执行次数(推迟执行次数):90%事务的响应时间|本轮测试最大响应时间
-- 第四列，支付业务的结果，后面几个的意义同上
-- 第五列，发货业务的结果，后面几个的意义同上
-- 第六列，库存业务的结果，后面几个的意义同上

-- 压测结束
STOPPING THREADS................................................................

   -- 第一次粗略结果统计
  [0] sc:100589  lt:0  rt:0  fl:0    -- New-Order，新订单业务成功(success,简写sc)次数，延迟(late,简写lt)次数，重试(retry,简写rt)次数，失败(failure,简写fl)次数
  [1] sc:100552  lt:0  rt:0  fl:0    -- Payment，支付业务统计，其他同上
  [2] sc:10059  lt:0  rt:0  fl:0    -- Order-Status，订单状态业务统计，其他同上
  [3] sc:10057  lt:0  rt:0  fl:0    -- Delivery，发货业务统计，其他同上
  [4] sc:10058  lt:0  rt:0  fl:0    -- Stock-Level，库存业务统计，其他同上
 in 120 sec.

    -- 第二次粗略统计结果，其他同上
  [0] sc:100590  lt:0  rt:0  fl:0 
  [1] sc:100582  lt:0  rt:0  fl:0 
  [2] sc:10059  lt:0  rt:0  fl:0 
  [3] sc:10057  lt:0  rt:0  fl:0 
  [4] sc:10059  lt:0  rt:0  fl:0 

 (all must be [OK])       -- 下面所有业务逻辑结果都必须为 OK 才行
 [transaction percentage]
        Payment: 43.47% (>=43.0%) [OK]      -- 支付成功次数(上述统计结果中 sc + lt)必须大于43.0%，否则结果为NG，而不是OK
   Order-Status: 4.35% (>= 4.0%) [OK]       -- 订单状态，其他同上
       Delivery: 4.35% (>= 4.0%) [OK]       -- 发货，其他同上
    Stock-Level: 4.35% (>= 4.0%) [OK]       -- 库存，其他同上
 [response time (at least 90% passed)]      -- 响应耗时指标必须超过90%通过才行
      New-Order: 100.00%  [OK]              -- 下面几个响应耗时指标全部 100% 通过
        Payment: 100.00%  [OK]
   Order-Status: 100.00%  [OK]
       Delivery: 100.00%  [OK]
    Stock-Level: 100.00%  [OK]


                 50294.500 TpmC                      -- TpmC结果值
注：tpm是transactions per minute的简称；C指TPC中的C基准程序。


###########################################################################################################################
tpcc-mysql测试cryptDB
1、创建数据库
	mysqladmin create yytest -h127.0.0.1 -P3307 -uroot -pletmein 
2、添加表
	mysql yytest -h127.0.0.1 -P3307 -uroot -pletmein < create_table.sql
3、加载数据
	./tpcc_load -h127.0.0.1 -P3307 -dyytest -uroot -pletmein -w1


###########################################################################################################################
push、fetch、pull
1、push做的事情
	a、修改本地的 origin/master
	b、提交到远程
2、示例如下：
	niuzibin@ubuntu:/home/disk1/GitTest$ git log -4 --oneline --decorate 
	8cbb6c4 (HEAD, master) a
	5109ccf (origin/master, origin/HEAD) b
	b87db1d a
	1e2d2d6 a
	niuzibin@ubuntu:/home/disk1/GitTest$ git diff origin/master master  
	diff --git a/readme.txt b/readme.txt
	index ccc3e7b..db754db 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-aaaaa
	+bbbbb
	niuzibin@ubuntu:/home/disk1/GitTest$ sudo git push origin master:master
	Counting objects: 5, done.
	Delta compression using up to 2 threads.
	Compressing objects: 100% (2/2), done.
	Writing objects: 100% (3/3), 242 bytes | 0 bytes/s, done.
	Total 3 (delta 1), reused 0 (delta 0)
	remote: Resolving deltas: 100% (1/1), completed with 1 local object.
	To https://github.com/nzbbody/GitTest
	5109ccf..8cbb6c4  master -> master
	niuzibin@ubuntu:/home/disk1/GitTest$ git log -4 --oneline --decorate   
	8cbb6c4 (HEAD, origin/master, origin/HEAD, master) a
	5109ccf b
	b87db1d a
	1e2d2d6 a
	niuzibin@ubuntu:/home/disk1/GitTest$ git diff origin/master master     
	niuzibin@ubuntu:/home/disk1/GitTest$ 
3、fetch做的事情
	仅仅修改本地的origin/master，也就是把远程master的数据拿回来
4、示例如下：
	niuzibin@ubuntu:/home/disk1/GitTest$ git fetch origin master
	remote: Counting objects: 3, done.
	remote: Compressing objects: 100% (1/1), done.
	remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
	Unpacking objects: 100% (3/3), done.
	From https://github.com/nzbbody/GitTest
	* branch            master     -> FETCH_HEAD
	8cbb6c4..c1e2a1e  master     -> origin/master
	niuzibin@ubuntu:/home/disk1/GitTest$ git diff origin/master master  
	diff --git a/readme.txt b/readme.txt
	index 1188fe1..db754db 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-ccccc
	+bbbbb
5、需要merge一下
	git merge origin/master
6、pull做的事情
	【git pull origin master】 = 【git fetch origin master】 + 【git merge origin/master】
	
	

###########################################################################################################################
改了之后，如何保证等价
1、查询的sql打印出来，看看有没有%d %s
2、检查select 与handle_result的对应关系
3、检查return 是不是多了
4、namecnt要检查查询回来的数据
5、有子查询，怎么搞？
	SELECT o_id, o_entry_d, COALESCE(o_carrier_id,0) FROM orders WHERE o_w_id = ? AND o_d_id = ? AND o_c_id = ? AND o_id = "
                    " (SELECT MAX(o_id) FROM orders WHERE o_w_id = ? AND o_d_id = ? AND o_c_id = ?)",
6、


###########################################################################################################################
有一个重大的问题如下：

update导致其他的字段，发生变化，需要修改一下，先记录一下。
mysql> select * from warehouse;                       
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = 6 WHERE w_id = 1;        
Query OK, 1 row affected (0.00 sec)

mysql> select * from warehouse;                      
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 6     |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = w_ytd + 6 WHERE w_id = 1;
Query OK, 1 row affected (0.03 sec)

mysql> select * from warehouse;                              
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.00  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

w_ytd = w_ytd + 6 导致错误，需要找一下问题。
w_tax是 float存在问题，如果是int没有问题，

那我现在怎么做？
先把w_tax 不加密，来测试一把。也不行

w_ytd = 300000.00; 是写死的，因此，我使用 SET w_ytd = 6 这种方式，来设置。

INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\').....Q.#07000Error: Bad Query: [INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\')]
	Line 1736: Error Data: parse_sql

###########################################################################################################################
error: too few arguments to function ‘int MYSQLlex(void*, void*)’
       yychar = yylex (&yylval);
错误原因是：
bision3.0不兼容
sql_yacc.yy is incompatible with Bison 3.0
解决办法：
卸载老的bison，安装如下版本

wget http://launchpadlibrarian.net/140087283/libbison-dev_2.7.1.dfsg-1_amd64.deb
wget http://launchpadlibrarian.net/140087282/bison_2.7.1.dfsg-1_amd64.deb
sudo dpkg -i libbison-dev_2.7.1.dfsg-1_amd64.deb
sudo dpkg -i bison_2.7.1.dfsg-1_amd64.deb

然后删除 mysql-src目录，重新构建
###########################################################################################################################
Benchmark






###########################################################################################################################
BenchmarkSQL
1、创建数据库和表
	mysqladmin create tpcc -h127.0.0.1 -P3306 -uroot -pletmein
	./runSQL.sh mysql.properties sqlTableCreates
2、加载数据
	./loadData.sh mysql.properties numWarehouses 1
3、添加索引
	./runSQL.sh mysql.properties sqlTableCreates
4、测试
	./runBenchmark.sh mysql
	



###########################################################################################################################






###########################################################################################################################	
BenchmarkSQL-233使用说明
1、







###########################################################################################################################




###########################################################################################################################
java版本的切换
1、找出java的路径
	niuzibin@ubuntu:/home/disk1/jdbc-client-test$ java -version
	java version "1.7.0_181"
	OpenJDK Runtime Environment (IcedTea 2.6.14) (7u181-2.6.14-0ubuntu0.1)
	OpenJDK 64-Bit Server VM (build 24.181-b01, mixed mode)
	
	niuzibin@ubuntu:/home/disk1/jdbc-client-test$ whereis java
	java: /usr/bin/java /usr/bin/X11/java /usr/share/java /usr/share/man/man1/java.1.gz
	
	niuzibin@ubuntu:/home/disk1/jdbc-client-test$ ll /usr/bin/java
	lrwxrwxrwx 1 root root 22 Jul  7 23:06 /usr/bin/java -> /etc/alternatives/java*
	
	niuzibin@ubuntu:/home/disk1/jdbc-client-test$ ll /etc/alternatives/java
	lrwxrwxrwx 1 root root 46 Jul  7 23:06 /etc/alternatives/java -> /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java*
	
	niuzibin@ubuntu:/home/disk1/jdbc-client-test$ ll /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java
	-rwxr-xr-x 1 root root 6408 Jun  9 02:10 /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java*
2、找到1.8版本的java，然后设置软连接
	sudo ln -s /home/niuzibin/work/FLKDBEnc/FLKWebCrypt/third_parties/jdk1.8.0_162/bin/java /etc/alternatives/java -f
3、	
###########################################################################################################################
gitlab markdown
测试一下





###########################################################################################################################
client gui
1、使用java 1.8
2、添加MySQL Driver Extra Class Path
3、添加 Example Url
	jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf-8&user=root&password=letmein
	test是已存在的数据库
	配置正确，显示对号
4、添加别名
	找到MySQL Driver
	点击 login 测试
5、点击login测试，会出现一些问题，解决办法如下
	a、在文件 /etc/environment添加如下
		export EDBDIR=/home/niuzibin/work/FLKDBEnc/FLKCDP
		export CRYPTDB_SHADOW=${EDBDIR}/shadow	
		为了让修改起效，需要执行source /etc/environment
	b、在终端执行 source /etc/environment之后，然后启动 squirrel-sql.sh，如何找到 squirrel-sql.sh
		sudo find / -iname "*squirrel*"
		另外，通过桌面也能找到，如下：
		niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP/tests$ sudo find / -iname "*squirrel*"
		/home/niuzibin/.local/share/applications/SQuirreL SQL Client-1531207135031.desktop
		/home/niuzibin/squirrel-sql-3.8.1/doc/licences/squirrel_licence.txt
		/home/niuzibin/squirrel-sql-3.8.1/squirrel-sql.sh
		niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP/tests$ cd /home/niuzibin/.local/share/applications/
		niuzibin@ubuntu:~/.local/share/applications$ more SQuirreL\ SQL\ Client-1531207135031.desktop 
		[Desktop Entry]
		Categories=
		Comment=An ISQL tool
		Comment[en]=An ISQL tool
		Encoding=UTF-8
		Exec=/home/niuzibin/squirrel-sql-3.8.1/squirrel-sql.sh
###########################################################################################################################
2018-07-10 23:13:28: (critical) plugin proxy 0.8.4 started
180710 23:13:50 InnoDB: The InnoDB memory heap is disabled
180710 23:13:50 InnoDB: Mutexes and rw_locks use GCC atomic builtins
180710 23:13:50 InnoDB: Compressed tables use zlib 1.2.8
180710 23:13:50 InnoDB: Using Linux native AIO
180710 23:13:50 InnoDB: Initializing buffer pool, size = 128.0M
180710 23:13:50 InnoDB: Completed initialization of buffer pool
180710 23:13:50  InnoDB: Operating system error number 2 in a file operation.
InnoDB: The error means the system cannot find the path specified.
InnoDB: If you are installing InnoDB, remember that you must create
InnoDB: directories yourself, InnoDB does not create them.
InnoDB: File name /usr/local/mysql/${EDBDIR}/shadow/ibdata1
InnoDB: File operation call: 'create'.
InnoDB: Cannot continue operation.


###########################################################################################################################
批量修改图片的属性
1、全选所有图片：开始－－编辑－－查找和选择－－定位条件，点选“对象”，确定；
2、右击任一图片，大小和属性，属性选项卡，点选“对象位置”中“大小和位置随单元格而变”。
###########################################################################################################################
增加透传的测试功能，TRUNCATE、SQLCOM_SHOW_PROCESSLIST,SQLCOM_SHOW_ENGINE_LOGS,SQLCOM_SHOW_ENGINE_STATUS,SQLCOM_SHOW_ENGINE_MUTEX,SQLCOM_SHOW_MASTER_STAT,SQLCOM_SHOW_SLAVE_STAT

增加4个透传命令的测试功能，以及函数测试，去除同一类，支持率达到70%

###########################################################################################################################
验证流程：
1、每个测试结果点击一下，看看是否有图片显示不对。
2、修改的代码好好检查，commit，添加详细支持的log
3、自动化跑一遍
4、push代码
5、提交 FunctionTest，添加详细的log





