###########################################################################################################################
如何测试embed_tool
1、先清空shadow目录和远端mysql中的数据库
2、启动proxy，调用测试脚本，生成shadow目录
3、把【1】中的aaa目录清空，scp拷贝shadow过去，导出aaa.sql文件。
4、导出xml文件，清空shadow_2，导入shadow_2
5、把【1】中的aaa目录清空，scp拷贝shadow过去，导出bbb.sql文件。
6、对照一把sql文件
7、使用shadow进行测试
8、然后再使用shadow_2测试
	

###########################################################################################################################
密码学有关
密码学6个重要工具：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器


###########################################################################################################################
kms密钥管理服务器
1、kms是密钥管理服务器，需要向kms获取密钥，是否支持用户设置？
2、要向kms获取密钥，需要一组参数，这组参数确定密钥
3、客户端和kms交互，需要会话密钥，这就涉及密钥配送的问题，解决这个问题，使用公钥密码，向服务端请求公钥。
4、客户端请求，使用服务端的公钥SM2，对会话密钥加密。
5、考虑到会话密钥的


3、获取过程是经过网络的，如果请求是明文，第三方可以截取到，存在风险。
4、怎么解决？
	客户端的请求要加密，服务端先传一个公钥。
5、服务端传输的密钥，也需要加密
	需要客户端传输密钥
6、
	

###########################################################################################################################
重要的错误
安装sudo apt install libmysqld-dev
导致assert(0 == mysql_thread_init());//初始化线程环境，断言失败



###########################################################################################################################
同时生成静态库和动态库



###########################################################################################################################
merge
1、如果没有分叉，从dev合并，就是 Fast-forward
2、本地合并，存在冲突。
	
###########################################################################################################################
origin
1、origin是个远程地址，通过下面的语句可以看到
	root@ubuntu:/home/disk1/GitTest# git remote -v
	origin  https://github.com/nzbbody/GitTest (fetch)
	origin  https://github.com/nzbbody/GitTest (push)


###########################################################################################################################
加密模式的区别
1、SENSITIVE等级最高，BEST_EFFORT相对于SENSITIVE，只是多了一个洋葱，支持剥到明文，PLAIN就是明文。
2、BEST_EFFORT和SENSITIVE，会根据实际需要配置洋葱层，在使用的过程中，为了支持，会剥掉洋葱。





###########################################################################################################################
DETJOINFactory 和 DETFactory 什么区别？
std::unique_ptr<EncLayer>
DETFactory::create(const Create_field &cf, const std::string &key)
{
    if (isMySQLTypeNumeric(cf)) {
        if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            FAIL_TextMessageError("decimal support is broken");
        } else {
            return std::unique_ptr<EncLayer>(new DET_int(cf, key));
        }
    } else {
        return std::unique_ptr<EncLayer>(new DET_str(cf, key));
    }
}

std::unique_ptr<EncLayer>
DETFactory::deserialize(unsigned int id, const SerialLayer &sl)
{
    if ("DET_int" == sl.name) {
        return DET_abstract_integer::deserialize<DET_int>(id,
                                                       sl.layer_info);
    } else if ("DET_dec" == sl.name) {
        FAIL_TextMessageError("decimal support broken");
    } else if ("DET_str" == sl.name) {
        return std::unique_ptr<EncLayer>(new DET_str(id, sl.layer_info));
    } else {
        FAIL_TextMessageError("Unknown type for DET deserialization!");
    }
}


###########################################################################################################################
OPE剥洋葱的细节
1、varbinary当成varchar使用
2、RND剥洋葱涉及到salt，其它的剥洋葱不涉及
3、由于加上了OPEJOIN，也就是 【【【OPEJOIN】OPE】RND】
	这就要剥洋葱 OPE， RND剥掉之后，就需要剥掉OPE，秘钥不同
4、为什么不需要 OPE_str::decryptUDF ？
	static onionlayout STR_ONION_LAYOUT = 
	{
    {oDET, std::vector<SECLEVEL>({SECLEVEL::DETJOIN, SECLEVEL::DET,
                                  SECLEVEL::RND})},
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
    {oSWP, std::vector<SECLEVEL>({SECLEVEL::SEARCH})}
    // {oSWP, std::vector<SECLEVEL>({SECLEVEL::PLAINVAL, SECLEVEL::DET,
                                  // SECLEVEL::RND})}
	};
	因为string的OPE是 {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
	string--OPEJOIN-->int--OPE-->int， 这里的OPE是对int处理，所以剥掉的也是OPE_int
5、对于string的OPE操作，只能比较前面4个字节，为什么？
	因为OPE算法只对前面4个字节，加密，加密的结果是 varbinary(32), 32个字节。
6、为什么只对前面4个字节加密？
	因为string的长度是不确定的，没有办法支持加密后的结果进行OPE比较。
7、为什么对前面4个字节加密，select出来的结果，是完整的？
	因为select的是eq这个洋葱，作为判断使用的是ope洋葱。
###########################################################################################################################	
mysql的varbinary
1、select出来varbinary看到的值不是字节的值，而是字节的ASCCI值。如下：
	CREATE TABLE test1 (c1 VARBINARY(3));
	INSERT INTO test1 set c1 = 0x61;
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	+----+
	1 row in set
2、再添加一个记录，如下：
	mysql> INSERT INTO test1 set c1 = 0x31;
	Query OK, 1 row affected
	
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	| 1  |
	+----+
	2 rows in set
	注意：这里的1是ASCCI值，取值为49
###########################################################################################################################
快捷键
1、word的F4，重复上一步操作
2、excel中 Ctrl+E 操作


###########################################################################################################################
cmake自动生成目录lib
1、对于下面的命令，cmake自动生成目录lib
	SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)


###########################################################################################################################	
思考洋葱的流程
1、考虑 select * from grade1 where chn > math; 流程是什么？
2、通过抓包发现，上面的sql语句重写为
	select `yytest`.`table_RINDNVZYLV`.`RQDCHMVSRGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltSTCMIHZRPQ`,`yytest`.`table_RINDNVZYLV`.`MDSBNIFRBHoEq`,`yytest`.`table_RINDNVZYLV`.`BVGEQNNIUDoEq`,`yytest`.`table_RINDNVZYLV`.`JBECZAOQOGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltWMPCQHRDPL` from `yytest`.`table_RINDNVZYLV` where (`yytest`.`table_RINDNVZYLV`.`MRTWUKQORQoOrder` > `yytest`.`table_RINDNVZYLV`.`GCLJSYADDKoOrder`)
3、我先思考，如果是自己做，思路是什么？
	a、要把*转化为对应的字段，一个字段扩展为多个洋葱，我使用哪一个洋葱呢？
		要选用加密过程没有信息丢失的洋葱，也就是说，可以解密的。OPE加密就会信息丢失，对于string只取前面4个字节。
		因此，这里选用eq洋葱，把*转化为每个字段的eq洋葱，因为解密还涉及到盐值，所以要select盐值字段。
	b、chn > math 涉及到两个洋葱比较，大于号决定了使用OPE洋葱，chn和math使用对应的OPE洋葱，而且要剥掉RND，OPE，到了OPE_JOIN这一层，密钥相同，就可以比较了。
		能否支持 chn > math，需要考虑哪个洋葱，以及洋葱的最里层。如下：
		const EncSet EQ_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DET, NULL)},
				{oOPE,   LevelFieldPair(SECLEVEL::OPE, NULL)},
			}
		};
		
		const EncSet JOIN_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DETJOIN, NULL)},
			}
		};
		上面是初始化的洋葱集合，以及每个洋葱的最里层。
	c、select是eq洋葱，select回来的结果，也要使用eq洋葱解密。



###########################################################################################################################
【ModernCPP_01】理解模板型别推导
1、示例代码如下：
	template<typename T>
	void f(ParamType param);
	
	f(expr);
2、先增加打印类型的代码，如下：
	#include <string>
	#include <type_traits>
	#include <typeinfo>
	#ifndef _MSC_VER
	# include <cxxabi.h>
	#endif
	#include <memory>
	#include <string>
	#include <cstdlib>	
	
	template <class T>
	std::string type_name()
	{
		typedef typename std::remove_reference<T>::type TR;
		std::unique_ptr<char, void(*)(void*)> own
			(
	#ifndef _MSC_VER
			abi::__cxa_demangle(typeid(TR).name(), nullptr,
			nullptr, nullptr),
	#else
			nullptr,
	#endif
			std::free
			);
	
		std::string r;
		if (std::is_const<TR>::value)
		{
			r +="const ";
		}		
		if (std::is_volatile<TR>::value)
		{
			r +="volatile ";
		}
		r += (own!= nullptr? own.get() : typeid(TR).name());
		if (std::is_lvalue_reference<T>::value)
		{
			r +="&";
		}
		if (std::is_rvalue_reference<T>::value)
		{
			r +="&&";
		}
	
		return r;
	}
3、考虑第一种情况，ParamType是个指针或者引用，但不是万能引用
	a、若expr具有引用型别，现将引用部分去掉
	b、然后，对expr和ParamType的型别执行模式匹配，来决定T的型别


###########################################################################################################################
CItemMath_One和CItemStrconv




###########################################################################################################################
template<class CB>
ope_domain_range
OPE::search(CB go_low)
{
    blockrng<AES> r(aesk);
/*
    return lazy_sample(to_ZZ(0), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);
                      */

   return lazy_sample(-(to_ZZ(1) << (pbits - 1)), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);

}
导致ope_join测试用例失败

###########################################################################################################################
su与sudo的再次理解

加上




###########################################################################################################################
有一个重大的问题如下：

update导致其他的字段，发生变化，需要修改一下，先记录一下。
mysql> select * from warehouse;                       
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = 6 WHERE w_id = 1;        
Query OK, 1 row affected (0.00 sec)

mysql> select * from warehouse;                      
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 6     |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = w_ytd + 6 WHERE w_id = 1;
Query OK, 1 row affected (0.03 sec)

mysql> select * from warehouse;                              
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.00  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

w_ytd = w_ytd + 6 导致错误，需要找一下问题。
w_tax是 float存在问题，如果是int没有问题，

那我现在怎么做？
先把w_tax 不加密，来测试一把。也不行

w_ytd = 300000.00; 是写死的，因此，我使用 SET w_ytd = 6 这种方式，来设置。

INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\').....Q.#07000Error: Bad Query: [INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\')]
	Line 1736: Error Data: parse_sql


###########################################################################################################################
批量修改图片的属性
1、全选所有图片：开始－－编辑－－查找和选择－－定位条件，点选“对象”，确定；
2、右击任一图片，大小和属性，属性选项卡，点选“对象位置”中“大小和位置随单元格而变”。


###########################################################################################################################
验证流程：
1、每个测试结果点击一下，看看是否有图片显示不对。
2、修改的代码好好检查，commit，添加详细支持的log
3、自动化跑一遍
4、push代码
5、提交 FunctionTest，添加详细的log

###########################################################################################################################
配置runner ci
https://note.youdao.com/group/#/65827312/(full:pdf/201146002)




###########################################################################################################################
内存泄漏的代码好好整理一下



###########################################################################################################################
proxy failed to retrieve default database 这个问题，稍微处理一下

操作步骤
1、return tpcc注释掉，vi ../sqlhandler/rewrite/src/rewrite_util.cc 837行
2、调用rebuild_clear_all.sh
3、开启flkcdp，创建数据库 tpcc，然后关闭
4、直接return tpcc，true，然后 sudo make install
5、flkcdp >/dev/null 2>&1 
6、调用 test_load_flkcdp.sh


############################################################################################################################
1、熟练使用linux系统命令，熟悉Linux系统平台软件开发，具备Linux平台下C/C++/Python程序开发经验；
2、熟练使用C/C++，熟练掌握数据结构和算法、熟悉STL；
3、熟悉Mysql等关系型数据库产品，精通SQL语言，有数据库优化经验，优先考虑；
4、熟悉加密算法，优先考虑；
5、有良好的编码习惯，和编写高性能代码的意识；
6、具备良好的沟通技巧及团队合作精神，有工作热情，有较好的理解能力和学习能力。
############################################################################################################################





############################################################################################################################
create table staff(id int, name enc varchar(64), height enc float, weight enc float, basepay enc float, meritpay enc float, des enc varchar(128));
insert into staff value(1,"滕海明",178.5,176.25,1000.50,200.35,"I am Frank, hello");
insert into staff value(2,"陈明",170.5,150.25,900.15,310.45,"我叫陈明, 我来自上海");
insert into staff value(3,"杨万年",171.5,155.25,984.15,264.45,"我是杨万年，我是安徽人，hello");
insert into staff value(4,"刘新超",172.25,165.25,635.15,561.45,"大家好，我是刘新超");
insert into staff value(5,"钟倩",162.5,100.25,844.15,190.45,"我是钟倩，九零后");
insert into staff value(6,"倪飞",173.25,163.25,987.15,256.45,"我叫倪飞，我是安徽人");
insert into staff value(7,"牛自宾",175.5,170.25,810.15,315.45,"我是牛自宾，我来自安徽");

create database aaa;
use aaa;
create table a1(id int);
insert into a1 value(1),(2);

drop database aaa;
create database bbb;
use bbb;
create table b1(id int);
insert into b1 value(1),(2);


create database flktest;
use flktest;
create table staff(id int, name varchar(64));
insert into staff value(1,"Andy");


W0801 01:04:21.205687  6951 insert_handler.cc:48] [20180801 01:04:21.205687]aaaaa InsertHandler 150
W0801 01:04:21.205691  6951 Analysis.cc:901] [20180801 01:04:21.205690]aaaaa InsertHandler 151
W0801 01:04:21.205695  6951 Analysis.cc:915] [20180801 01:04:21.205695]aaaaa InsertHandler 1510
W0801 01:04:21.205708  6951 Analysis.cc:927] [20180801 01:04:21.205706]aaaaa InsertHandler 1511
W0801 01:04:21.205713  6951 Analysis.cc:931] [20180801 01:04:21.205711]aaaaa InsertHandler 1512
W0801 01:04:21.205715  6951 Analysis.cc:903] [20180801 01:04:21.205715]aaaaa InsertHandler 152
W0801 01:04:21.205724  6951 Analysis.cc:907] [20180801 01:04:21.205723]aaaaa InsertHandler 153
W0801 01:04:21.205729  6951 insert_handler.cc:56] [20180801 01:04:21.205727]aaaaa InsertHandler 200


W0801 01:04:50.933387  6951 insert_handler.cc:48] [20180801 01:04:50.933385]aaaaa InsertHandler 150
W0801 01:04:50.933389  6951 Analysis.cc:901] [20180801 01:04:50.933389]aaaaa InsertHandler 151
W0801 01:04:50.933393  6951 Analysis.cc:915] [20180801 01:04:50.933393]aaaaa InsertHandler 1510
W0801 01:04:50.933403  6951 Analysis.cc:927] [20180801 01:04:50.933403]aaaaa InsertHandler 1511
W0801 01:04:50.933408  6951 Analysis.cc:931] [20180801 01:04:50.933408]aaaaa InsertHandler 1512
W0801 01:04:50.933411  6951 Analysis.cc:903] [20180801 01:04:50.933411]aaaaa InsertHandler 152
W0801 01:04:50.933420  6951 Analysis.cc:907] [20180801 01:04:50.933419]aaaaa InsertHandler 153
W0801 01:04:50.933423  6951 insert_handler.cc:56] [20180801 01:04:50.933423]aaaaa InsertHandler 200


W0801 01:05:07.269625  6951 insert_handler.cc:48] [20180801 01:05:07.269624]aaaaa InsertHandler 150
W0801 01:05:07.269629  6951 Analysis.cc:901] [20180801 01:05:07.269628]aaaaa InsertHandler 151
W0801 01:05:07.269634  6951 Analysis.cc:915] [20180801 01:05:07.269633]aaaaa InsertHandler 1510
W0801 01:05:07.269645  6951 Analysis.cc:927] [20180801 01:05:07.269644]aaaaa InsertHandler 1511
W0801 01:05:07.269651  6951 Analysis.cc:931] [20180801 01:05:07.269650]aaaaa InsertHandler 1512
W0801 01:05:07.269654  6951 Analysis.cc:903] [20180801 01:05:07.269653]aaaaa InsertHandler 152
W0801 01:05:07.269665  6951 Analysis.cc:907] [20180801 01:05:07.269663]aaaaa InsertHandler 153
W0801 01:05:07.269668  6951 insert_handler.cc:56] [20180801 01:05:07.269667]aaaaa InsertHandler 200


W0801 01:21:54.518466  7311 insert_handler.cc:48] [20180801 01:21:54.518465]aaaaa InsertHandler 150
W0801 01:21:54.518471  7311 Analysis.cc:901] [20180801 01:21:54.518469]aaaaa InsertHandler 151
W0801 01:21:54.518483  7311 Analysis.cc:903] [20180801 01:21:54.518482]aaaaa InsertHandler 152
W0801 01:21:54.518492  7311 Analysis.cc:907] [20180801 01:21:54.518492]aaaaa InsertHandler 153
W0801 01:21:54.518496  7311 insert_handler.cc:56] [20180801 01:21:54.518496]aaaaa InsertHandler 200


W0801 01:22:11.590464  7308 insert_handler.cc:48] [20180801 01:22:11.590464]aaaaa InsertHandler 150
W0801 01:22:11.590468  7308 Analysis.cc:901] [20180801 01:22:11.590467]aaaaa InsertHandler 151
W0801 01:22:11.590481  7308 Analysis.cc:903] [20180801 01:22:11.590480]aaaaa InsertHandler 152
W0801 01:22:11.590490  7308 Analysis.cc:907] [20180801 01:22:11.590489]aaaaa InsertHandler 153
W0801 01:22:11.590493  7308 insert_handler.cc:56] [20180801 01:22:11.590493]aaaaa InsertHandler 200


W0801 01:22:25.222702  7308 insert_handler.cc:48] [20180801 01:22:25.222701]aaaaa InsertHandler 150
W0801 01:22:25.222705  7308 Analysis.cc:901] [20180801 01:22:25.222705]aaaaa InsertHandler 151
W0801 01:22:25.222718  7308 Analysis.cc:903] [20180801 01:22:25.222718]aaaaa InsertHandler 152
W0801 01:22:25.222728  7308 Analysis.cc:907] [20180801 01:22:25.222727]aaaaa InsertHandler 153
W0801 01:22:25.222731  7308 insert_handler.cc:56] [20180801 01:22:25.222730]aaaaa InsertHandler 200


方法调用本身的消耗
map的消耗

W0802 01:35:45.861238 14499 Cryptdb_Proxy.cc:365] [20180802 01:35:45.861227]aaaaa map begin
W0802 01:35:45.984206 14499 Cryptdb_Proxy.cc:379] [20180802 01:35:45.984143]aaaaa map end  


W0802 01:35:50.055317 14500 Cryptdb_Proxy.cc:365] [20180802 01:35:50.055306]aaaaa map begin
W0802 01:35:50.166303 14500 Cryptdb_Proxy.cc:379] [20180802 01:35:50.166274]aaaaa map end  


W0802 01:35:53.558717 14499 Cryptdb_Proxy.cc:365] [20180802 01:35:53.558706]aaaaa map begin
W0802 01:35:53.669787 14499 Cryptdb_Proxy.cc:379] [20180802 01:35:53.669758]aaaaa map end


W0802 01:38:12.773437 14733 Cryptdb_Proxy.cc:365] [20180802 01:38:12.773427]aaaaa map begin
W0802 01:38:12.837126 14733 Cryptdb_Proxy.cc:381] [20180802 01:38:12.837096]aaaaa map end  

W0802 01:38:16.437402 14732 Cryptdb_Proxy.cc:365] [20180802 01:38:16.437388]aaaaa map begin
W0802 01:38:16.505723 14732 Cryptdb_Proxy.cc:381] [20180802 01:38:16.505693]aaaaa map end  

W0802 01:38:19.927278 14733 Cryptdb_Proxy.cc:365] [20180802 01:38:19.927267]aaaaa map begin
W0802 01:38:19.989336 14733 Cryptdb_Proxy.cc:381] [20180802 01:38:19.989307]aaaaa map end




############################################################################################################################
性能测试数据
1、
	create database flktest;
	use flktest;
	create table staff(id int, name enc varchar(64));
	insert into staff value(1,"Andy");
2、目前定位到，rewrite流程：
	任何一条sql请求，rewrite流程，都会执行两个查询，
	一个是	SELECT db FROM INFORMATION_SCHEMA.PROCESSLIST  WHERE id = 59; 根据连接线程，向mysql获取当前使用的数据库， 600多微秒
	另一个是 select stale from generic_prefix_staleness where cache_id=5; 从embedded_db查询，stale值，判断当前内存与embedded_db是否同步，200多微秒	
	I0724 05:30:57.035692 13388 rewrite_util.cc:838] [20180724 05:30:57.035680]---rewrite--- bbbbb retrieveDefaultDatabase 
	I0724 05:30:57.035710 13388 rewrite_util.cc:848] [20180724 05:30:57.035709]---rewrite--- bbbbb 111 
	I0724 05:30:57.036346 13388 rewrite_util.cc:851] [20180724 05:30:57.036342]---rewrite--- bbbbb 112 
	I0724 05:30:57.036366 13388 rewrite_util.cc:863] [20180724 05:30:57.036365]---rewrite--- bbbbb retrieveDefaultDatabase 
	【int Proxy::dorewrite】
	I0724 05:30:57.036384 13388 schema.cc:615] [20180724 05:30:57.036383]---rewrite--- bbbbb lowLevelGetCurrentStaleness 
	I0724 05:30:57.036751 13388 schema.cc:630] [20180724 05:30:57.036746]---rewrite--- bbbbb lowLevelGetCurrentStaleness
	【return shared.cache.getSchema(this->getConn(), this->getEConn());】
3、next流程
	I0725 03:52:51.331641  9159 Cryptdb_Proxy.cc:959] [20180725 03:52:51.331638]---next--- ccccc begin 
	I0725 03:52:51.332839  9159 Cryptdb_Proxy.cc:961] [20180725 03:52:51.332833]---next--- ccccc end 
	I0725 03:52:51.336182  9158 Cryptdb_Proxy.cc:959] [20180725 03:52:51.336173]---next--- ccccc begin 
	I0725 03:52:51.338012  9158 Cryptdb_Proxy.cc:961] [20180725 03:52:51.338004]---next--- ccccc end 
	【genericPreamble(nparams);】
4、什么时候，得到new query
	在哪里返回的？
	
	
5、Debug信息
	error.hh
	
create database tpcc; 
use tpcc;
create table t1(id int);

############################################################################################################################
获取系统时间，精度微秒



############################################################################################################################
find ../ -iname "*.so" |xargs ls -thl


grep "O3" ./ -Rn

############################################################################################################################

select sql_no_cache idn+rev_idn from bench1 where idn=5;



W0809 02:31:50.528110  6117 base_rewrite_main.cc:1028] [20180809 02:31:50.528084]aaaaa hom decrypt begin
W0809 02:31:53.808254  6117 base_rewrite_main.cc:1033] [20180809 02:31:53.808239]aaaaa hom decrypt end

W0809 02:32:00.209451  6116 base_rewrite_main.cc:1028] [20180809 02:32:00.209426]aaaaa hom decrypt begin
W0809 02:32:03.471449  6116 base_rewrite_main.cc:1033] [20180809 02:32:03.471432]aaaaa hom decrypt end

W0809 02:32:08.703430  6118 base_rewrite_main.cc:1028] [20180809 02:32:08.703404]aaaaa hom decrypt begin
W0809 02:32:11.988782  6118 base_rewrite_main.cc:1033] [20180809 02:32:11.988768]aaaaa hom decrypt end

3280155
3262006
3285364


修改HOM算法的位数，测试一把
sk = new Paillier_priv(Paillier_priv::keygen(prng.get(), nbits)); 修改为512 变成死循环，出不来了，估计还要同时修改其他的参数。


create database sql_bench;
use sql_bench;
create table bench1
(
region enc char(1) NOT NULL,idn enc integer(6) NOT NULL,rev_idn enc integer(6) NOT NULL,grp enc integer(6) NOT NULL,
primary key a (region,idn),unique b (region,rev_idn),unique c (region,grp,idn)
);

insert into bench1 value('A',100,200,300);



############################################################################################################################
先把原来的代码修改一下
1、去掉调试日志，默认使用release版本
2、在不加密的情况下，插入数据，然后测试select的性能消耗，测试10000次，来看消耗
3、
############################################################################################################################
测试的数据
1、插入1万条数据，每次查询语句是 select sql_no_cache idn, rev_idn from bench1 where idn=100;
2、查询5万次，比较mysql和flkcdp，每次select多消耗的时间
	mysql：
	test select[select sql_no_cache idn, rev_idn from bench1 where idn=100] 
	Time to select (50000): 46 wallclock secs ( 1.48 usr +  0.29 sys =  1.77 CPU)
	
	flkcdp：
	test select[select sql_no_cache idn, rev_idn from bench1 where idn=100] 
	Time to select (50000): 71 wallclock secs ( 0.37 usr +  2.96 sys =  3.33 CPU)
	
	每一次select多消耗的时间是 (71-46)*1000000/50000 = 500微秒，也就是说，每一次select，流程上的消耗是500微秒	
3、确认消耗时间的瓶颈，注意我们的release带有debug信息，只是进行了O3优化
	这500微秒消耗在哪里？
	Rewriter::rewrite
	W0809 23:32:40.834921 16593 Cryptdb_Proxy.cc:389] [20180809 23:32:40.834907]aaaaa 100
	W0809 23:32:41.815474 16593 Cryptdb_Proxy.cc:394] [20180809 23:32:41.815462]aaaaa 200
	
	W0809 23:32:45.490936 16592 Cryptdb_Proxy.cc:389] [20180809 23:32:45.490926]aaaaa 100
	W0809 23:32:46.464092 16592 Cryptdb_Proxy.cc:394] [20180809 23:32:46.464079]aaaaa 200
	
	W0809 23:32:49.797080 16592 Cryptdb_Proxy.cc:389] [20180809 23:32:49.797065]aaaaa 100
	W0809 23:32:50.756587 16592 Cryptdb_Proxy.cc:394] [20180809 23:32:50.756576]aaaaa 200
	
	980555 + 973153 + 959511 = 971073 / 10000 = 97 微秒	
	
	还有其他的开销在哪里？
	
	
	
	
W0809 23:55:14.146692 19130 Cryptdb_Proxy.cc:389] [20180809 23:55:14.146682]aaaaa 100
W0809 23:55:15.191277 19130 Cryptdb_Proxy.cc:394] [20180809 23:55:15.191262]aaaaa 200
W0809 23:55:15.191814 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:15.191808]aaaaa 300
W0809 23:55:15.192049 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:15.192043]aaaaa 400
W0809 23:55:15.194294 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:15.194286]aaaaa 300
W0809 23:55:15.194571 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:15.194564]aaaaa 400


W0809 23:55:19.186285 19130 Cryptdb_Proxy.cc:389] [20180809 23:55:19.186276]aaaaa 100
W0809 23:55:20.272120 19130 Cryptdb_Proxy.cc:394] [20180809 23:55:20.272108]aaaaa 200
W0809 23:55:20.272591 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:20.272587]aaaaa 300
W0809 23:55:20.272758 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:20.272754]aaaaa 400
W0809 23:55:20.274210 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:20.274205]aaaaa 300
W0809 23:55:20.274444 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:20.274440]aaaaa 400


W0809 23:55:23.668009 19130 Cryptdb_Proxy.cc:389] [20180809 23:55:23.668000]aaaaa 100
W0809 23:55:24.698678 19130 Cryptdb_Proxy.cc:394] [20180809 23:55:24.698663]aaaaa 200
W0809 23:55:24.699545 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:24.699500]aaaaa 300
W0809 23:55:24.699802 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:24.699799]aaaaa 400
W0809 23:55:24.701290 19130 Cryptdb_Proxy.cc:447] [20180809 23:55:24.701284]aaaaa 300
W0809 23:55:24.701552 19130 Cryptdb_Proxy.cc:449] [20180809 23:55:24.701548]aaaaa 400

############################################################################################################################
1、基准测试，需要测试的情况
	a、计算一下void   GetSystemTime(timeval& tv); 本身的耗时，本身耗时 0.17微秒，因此可以忽略不计
	b、对于没有副作用的函数，直接调用多次，统计每次的耗时
	c、对于有副作用的函数，客户端执行多次，在达到多次的情况下，统计一下耗时
2、
static int rewrite 156微秒
static int next    54微秒

    /*
    static int count = 0;
    static int sum = 0;
    timeval begin;
    FLKCDP::GetSystemTime(begin);    
    */

    ANON_REGION(__func__, &perf_cg);
    scoped_lock l(&big_lock);
    mysqlProxy<lua_State> nextObj(L);
    std::string client;
    const ResType &res = nextObj.getnextArg(client);

    int ret = nextObj.donext(client, res);

    /*
	timeval end;
    FLKCDP::GetSystemTime(end);
    sum += FLKCDP::SubSystemTime(begin,end);
    if(count%10000 == 0)
    {
        LOG(WARNING)<<"xxx time["<< sum <<"] count["<< count <<"]";
        sum = 0;
    }
    ++count;
    */

timeval begin;
FLKCDP::GetSystemTime(begin);
for(int i =0; i<10000; ++i)
{
    std::unique_ptr<QueryRewrite> qr = std::unique_ptr<QueryRewrite>(new QueryRewrite(Rewriter::rewrite(query, *schema.get(), c_wrapper->default_db, *ps)));
}
timeval end;
FLKCDP::GetSystemTime(end);
LOG(WARNING)<<"Rewriter::rewrite["<< FLKCDP::SubSystemTime(begin,end) <<"]";



############################################################################################################################
优化的处理
1、保存原始sql语句对应的改写sql语句，在什么地方添加，整个流程走完，才添加。
2、知道怎么解密，他是next流程来的，只有结果，和client，我怎么找到

############################################################################################################################
北京石景山区保障房中心

drop database flktest;
create database flktest;
use flktest;
create table staff(id int, name varchar(64));
insert into staff value(1,"Andy"),(2,"Bill"),(3,"Caroline");

select * from staff where id=2;

############################################################################################################################
修改的内容
加上日志
static LogClassInit l;


strncasecmp 直接写死，提高性能
改成 newRes

                const auto &res = new_results.second->extract<ResType>();
                ret = setResResults(res);
                if(new_results.second)
                {
                    delete new_results.second;
                }

sleep立即去掉
            LOG(INFO)<<"Check License failed";
            sleep(10);
############################################################################################################################
1、对查询语句缓存，把rewrite流程【改写sql】的时间开销，全部节省下来，现在达到查询一万次（不考虑加解密的瓶颈），耗时2.6秒，
	2.6秒消耗，2.1秒在多一层代理的时间开销。
2、
############################################################################################################################
DBI和DBD
1、DBI是DB interface
2、DBD是DB Driver，包括mysql、oracle等
############################################################################################################################
perl mysql绑定变量
1、

create database yytest;
use yytest;
create table staff(id int, name varchar(64));
insert into staff value(1,"Andy"), (2,"Bill");

select * from staff;





my $sth = $dbh ->prepare('select * from staff where id = ?'); 
my @ids = qw/1 2 3 4 5/;
 
foreach my $id (@ids) 
{
    $sth->execute($id);  
    print "\$sth is $sth\n";
	while (my  @arr = $sth->fetchrow_array())
	{
	    print "@arr\n";
    }
}




http://outofmemory.cn/code-snippet/2798/Perl-call-MySQL-cunchuguocheng-get-fanhuizhi



############################################################################################################################
qw
1、qw(100 200 300); 或者 qw/100 200 300/; 等价于 ('100','200','300'); 如下：
	#!/usr/bin/perl
	
	#@arr = (100,200,300);
	#@arr = ('100','200','300');
	#@arr = qw(100 200 300);
	@arr = qw/100 200 300/;
	
	foreach my $a (@arr)
	{
		print "$a\n";
	}
############################################################################################################################
JDBC绑定变量
1、需要设置 useServerPrepStmts=true&cachePrepStmts=true


############################################################################################################################
代码逻辑的测试
1、

create table student(id enc int, name enc varchar(64));
insert into student(id, name) value(1,"Andy"),(2,"Bill"),(3,"Caroline"),(4,"David");
create table teacher(id enc int, name enc varchar(64));
insert into teacher(id, name) value(1,"Mr Li"),(2,"Ms Wang"),(3,"Mr Zhang"),(4,"Mr He");
create table grade(id enc int, name enc varchar(64), stuid enc int, teaid enc int, score enc int);
insert into grade(id,name,stuid,teaid,score) value(1,"Math",1,2,85),(2,"Math",2,2,86),(3,"Math",3,2,87),(4,"Math",4,2,88),(5,"Math",5,2,89),(6,"Math",6,2,90);


select * from student;


select S.name from student as S;



select student.name, G.score from student inner join grade as G on student.id = G.stuid;


select * from (select * from student where id >1) as S where S.name="Bill";


select student.name, grade.name from student,grade where student.id = grade.stuid;






select S.id, S.name from student as S;


select * from student;



select id from student;

select min()



两者的差别：

select name from student where id > 2;
走到字段比较

select student.name, grade.name from student,grade where student.id = grade.stuid;
走到function比较



select * from student order by id desc;


select student.name, G.score from student inner join grade as G on student.id = G.stuid;

select student.name, G.score from student,grade as G where student.id = G.stuid;





create table student(id int, name varchar(64));
insert into student(id, name) value(1,"Andy"),(2,"Bill"),(3,"Caroline"),(4,"David");
create table teacher(id int, name varchar(64));
insert into teacher(id, name) value(1,"Mr Li"),(2,"Ms Wang"),(3,"Mr Zhang"),(4,"Mr He");
create table grade(id int, name varchar(64), stuid int, teaid int, score int);
insert into grade(id,name,stuid,teaid,score) value(1,"Math",1,2,85),(2,"Math",2,2,86),(3,"Math",3,2,87),(4,"Math",4,2,88),(5,"Math",5,2,89),(6,"Math",6,2,90);





############################################################################################################################
如何做汇报
1、做给谁看，想表达什么？
2、





############################################################################################################################

https://wenku.baidu.com/view/452a5a87a0c7aa00b52acfc789eb172ded6399cc.html?sxts=1535936565857###&nu_token=





############################################################################################################################

select count(1) from customer;select count(1) from district;select count(1) from history;select count(1) from item;select count(1) from new_order;select count(1) from order;select count(1) from order_line;select count(1) from stock;select count(1) from warehouse;






############################################################################################################################
做给谁看？想表达什么？
假如我是销帮帮的负责人，我期望得到什么？
1、同步明文过去，不能满足数据安全的需求
2、同步密文过去，支持的功能会非常受限，不能满足用户的功能需求
############################################################################################################################
1、密钥的导入导出工具
2、对接kms对masterkey的加解密
3、安全编码规范和检测工具的预研报告
4、FLKCDP的License功能和OPE JOIN功能
5、性能测试，使用了BenchmarkSQL和sql-bench
6、性能优化，优化和MySQL、Embedded_db的交互，增加SQL语句的缓存
############################################################################################################################
1、快速学习新的知识点和技能，包括cmake、lua脚本、Modern C++、git版本控制、密码学等，并在项目中熟练使用，并且帮助新员工
2、合理制定数据库加密项目的迭代开发计划，有效管控开发过程中的进度和质量
############################################################################################################################
1、4月份，输出密钥管理的文档，并组内分享
2、5月份，输出安全编码规范和检测工具的预研报告，给出我们项目应用的解决方案，并开发出秘钥导入导出的工具，完成kms对masterkey的加解密功能
3、6月份，在FLKCDP增加功能，完成License功能，OPE JOIN的功能，字符串单目函数的功能
4、7月份，增加FLKCDP支持的SQL，支持率达70%，并使用BenchmarkSQL工具输出性能测试报告
5、8月份，优化FLKCDP的性能，优化掉交互的流程，以及增加SQL语句的缓存，优化后达到cryptdb论文的指标
6、9月份，输出总的流程分析报告和优化点，并输出性能优化报告


############################################################################################################################
具体而言，存在以下问题 ：
[0008] 1、性能问题 ：一般应用中往往采用客户端数据解密的方式，将加密后的数据从数
据库取出后进行处理，严重影响数据库访问的性能，在数据记录比较大的情况下，基本不能
使用 ；
[0009] 2、不能进行全文检索 ：由于数据库存放密文，一般采用将密文取出解密后再进行
全文检索，效率比数据库系统直接检索慢，对系统的开销也很大 ；
[0010] 3、不同的用户不能共享 ：由于数据采用了用户专用的密钥进行加密，在数据需要
共享的场合，则对数据不能加密 ；
[0011] 4、对字段加密不能设置 ：对数据库字段的加密与否不能灵活选择，导致数据加密
性能问题严重 ；
[0012] 5、应用系统访问数据库不透明 ：应用系统需要对数据进行加密和解密的操作，不
透明

############################################################################################################################
专利的测试数据
create database test1;
create table staff(id int, name enc varchar(64), salary enc float);


create table staff 
(
id INT(11), 
nameoEQ VARBINARY(80), nameoORDER BIGINT(64) unsigned, nameoSWP BLOB, 
salaryoEQ BIGINT unsigned, salaryoORDER BIGINT unsigned, salaryoADD VARBINARY(1024)
)


select sum(`test1`.`staff`.`salaryoADD`) from `test1`.`staff`


############################################################################################################################
人力丁咨询问题：
体验了一下你们的产品，有些问题，再请教，确认一下：
1、服务端会有解密的需求吗？作为独立的第三方加密，原则上我们不提供服务端解密，否则失去用户的信任。 
2、涉及到过滤，运算的情况，你们目前的处理逻辑都是，从服务端取回密文数据，在客户端解密，然后再对明文过滤，运算，呈现结果的吗？


那目前来说，做了服务端的存储安全，网络传输是明文，不安全的。
那按照我的理解，你们的需求是端到端加密，但我们不提供服务端的解密。
这样的话，应该是客户端调用sdk，采用同态加解密的方式，实现网络传输安全，服务端直接对密文运算，运算结果返回给客户端解密。


############################################################################################################################
咱要和人力丁确认：
1、强制的要求是：端到端加密，服务端要求解密。
2、有一种办法，提供服务端密文运算的功能。有比较大的工作量：
	提供同态加密的sdk，各种版本（安卓、苹果、js、H5），我们目前只有C++的，而且需要从代码中提取。
	人力丁也需要调用相应的SDK
	
	
采用同态加密，提供sdk的方式。我们这边和你们那边都需要比较大的改动：
我们这边需要提供多个版本的同态加密sdk（安卓、苹果、js等），你们那边的客户端需要根据涉及的运算，调用对应的同态加密算法。
我们这边评估一下。	
############################################################################################################################
kms的流程
1、kms服务发送公钥给sdk，通过证书的方式。（或者公钥嵌入到sdk中）
2、sdk向kms请求对称密钥，kms根据企业ID等信息生成对称密钥，对称密钥本身需要加密传输。
	因此，sdk发送的信息包括企业ID，随机数（会话密钥加密对称密钥），这些信息需要使用公钥加密发送请求。
	回复的对称密钥，使用会话密钥加密。
3、sdk使用会话密钥，解密得到对称密钥，对真正的数据加密。考虑到对称密钥不会频繁变动，再产生一个加密数据的密钥，这个密钥由对称密钥加密生成。
	数据密钥可以经常变动，并且和数据保存在一起。
4、现在存在一个问题，任何用户都能从kms获取对称密钥，需要token认证。sdk首先登陆token服务器获取token，向kms获取对称密钥的时候，带着token
	然后kms向token服务器检查token，这个token服务器也可以是用户saas服务。类似之前的cmu、dmu、dmusdk。dmu会向cmu检查用户的token。
############################################################################################################################
端到端的同态加密，我们需要做哪些事情？
1、与kms对接，这个对接应该没有什么问题。
2、涉及到密文同态运算的，密钥要相同。否则数据没法进行同态运算。
3、要不要涉及加密数据的密钥，也放到数据库中？
4、多个版本（安卓、苹果、js【pc端的H5】）的同态加密SDK，工作量多大？
5、数据库要根据加密后的数据类型、以及要支持的同态运算，扩展字段。
6、数据库还需要注册UDF。
############################################################################################################################
1、192.168.10.71上面的测试环境搭建好了，测试的数据规模，就是benchmark原始的数据规模，一共60万记录
2、脚本
	/home/flk/source_code/eval-flkcdp/BenchmarkSQL-2.3.3/run/load_enc_no/test_load_mysql.sh 测试mysql的insert性能
	/home/flk/source_code/eval-flkcdp/BenchmarkSQL-2.3.3/run/load_enc/test_load_enc_int_one.sh 测试flkcdp的insert性能
	/home/flk/source_code/eval-flkcdp/BenchmarkSQL-2.3.3/run/tpmc_enc_no/tpmc_enc_no_mysql.sh 测试mysql的tpmc性能
	/home/flk/source_code/eval-flkcdp/BenchmarkSQL-2.3.3/run/tpmc_enc/tpmc_enc_int_one.sh 测试flkcdp的tpmc性能
	测试tpmc，不能在终端测试，需要在主机上测试。
	
	
	
	
	









############################################################################################################################
测试分词长度大于16的情况
create database yytest;
use yytest;
create table staff(id int, name enc varchar(64));
insert into staff value(1, "012345678912345");

insert into staff value(1, "01234567890123456789012345678901");

insert into staff value(1, "012345678901234567890123456789012345678901234567");

insert into staff value(1, "8wqwyHWT/ieMOow3iL1ZNktlj2JLGHTmcfzA5KPP9o1BO9VQyfoEwQGGrSnsCh5WJbMco5y8RQcxVK6K2gzv4pVuWRBaSxs1QcueRAFlBmI");

'8wqwyHWT/ieMOow3iL1ZNktlj2JLGHTmcfzA5KPP9o1BO9VQyfoEwQGGrSnsCh5WJbMco5y8RQcxVK6K2gzv4pVuWRBaSxs1QcueRAFlBmI'

############################################################################################################################
1、FLKCDP流程梳理，输出性能瓶颈和性能优化方案。
2、FLKCDP性能优化，主要包括流程上的优化、加解密算法的优化，查询缓存的优化。
3、数据库管理后台，使用jdbc替换掉porxy
4、FLKJDBC提供SDK的方式和说明文档
5、持续集成增加FLKJDBC的测试用例
############################################################################################################################
------------- LoadJDBC Statistics --------------------
     Start Time = Thu Sep 27 14:49:10 CST 2018
       End Time = Thu Sep 27 15:56:14 CST 2018
       Run Time = 4024403 Milliseconds
    Rows Loaded = 598328 Rows
Rows Per Second = 148 Rows/Sec
------------------------------------------------------

VNC的端口
192.168.10.244:5913

全部加密，tpmc流程会有大量失败，导致rollback，因为tpmc模拟订单系统，
############################################################################################################################
v1.1.0 2018年9月底release版本v1.0.0

git tag -a v1.1.0 -m"2018年9月底release版本v1.1.0"
git push origin v1.1.0

############################################################################################################################
10月份的计划
1、FLKCDP功能的完善
	DDL操作多线程问题的修改
	嵌套SQL语句的支持
	多目函数功能的支持
	密文之间乘除同态运算的支持
2、FLKJDBC
	FLKJDBC分布式部署的应用
3、数据库管理后台
	密钥导入导出备份的功能
	JDBC增加测试用例
4、数据库加密应用到内部项目
	数据库加密应用到内部的订单系统，测试验证，输出问题
	数据库加密应用到内部的云密盾系统，测试验证，输出问题
	解决出现的问题
	输出报告	
5、数据库加密有关专利
	SQL语句改写优化策略，输出一篇专利
############################################################################################################################

curl -u uftp:hzflk1234 -T $DEBNAME  ftp://192.168.10.70/flksoft/release/

curl -u uftp:hzflk1234 ftp://192.168.10.70/flksoft/release/FLK_JDBC_SDK_v1.1.0.tar.gz -O




############################################################################################################################
一， 设置DEBUG编译选项
find . -name Makefile.am -exec sed -i '1i\CFLAGS=-g' '{}' \;
find . -name Makefile.am -exec head -1 '{}' \;

二， 编译
./autogen.sh
./configure --enable-maintainer-mode --with-lua=lua5.1 --prefix=/home/niuzibin/work/FLKDBEnc/FLKCDP/bins/proxy-bin
grep -R -n "\\-O2" .
make & make install
############################################################################################################################
CLion调试报错
1、CLion调试报错如下：
	network-mysqld-lua.c:234: lua_load_file(/home/niuzibin/work/FLKDBEnc/FLKCDP/bins/proxy-bin/$EDBDIR/bin/wrapper.lua) failed
2、错误原因是：
	没有选中Debug按钮，而是选中了Run按钮。选中Run还有一个特点，就是断点不起作用。
############################################################################################################################
增加功能，最大分词长度可以配置。





############################################################################################################################
create table staff(id enc int, name enc varchar(64));

insert into staff value(1, "012345678912345");

select * from student where teacherid = (select id from teacher where name = "Mr Li");

update staff set salary = salary+100;
下面的update也是不行的，update staff set salary = 100; 这样可以，分别调用洋葱加密，
但是 update staff set salary = 100; 不行，没有办法改写。因为DET、OPE、HOM只有HOM具备加法同态。


create table staff(id enc int, name enc varchar(64), salary enc float);
insert into staff value (1, "Andy",100.00), (2, "Bill",200.00),(3, "Caroline",300.00);

############################################################################################################################
flkcdp insert一次耗时 1398微秒
mysql  insert一次耗时 270微秒
多消耗 1398-270 = 1128，而日志打印，多消耗942微秒


flkcdp select一次耗时 16949微秒
mysql  select一次耗时  8695微秒
多消耗 16949-8695 = 8254，而日志打印，多消耗500微秒

1000/27 - 1000/35 = 8466

1000/32 - 1000/48 = 10417
############################################################################################################################

mysql-proxy --plugins=proxy --event-threads=4 --max-open-files=1024 --proxy-address=0.0.0.0:3307 --proxy-backend-addresses=127.0.0.1:3306


############################################################################################################################
配置文件在本地，edb.so放到远程mysql，暂时不支持配置分词的最大长度，目前写死1024



############################################################################################################################
update staff  set salary = salary+100;
select sum(price) as total from orders group by order_id having total > 100;

select floor(salary) from staff;
update staff  set salary = salary+100;

select * from staff where salary>100;

select * from student where teacherid = (select id from teacher where name = "Mr Wang");

############################################################################################################################
假设只有5门课程，查询总分大于500的，select name from student group by name having sum(grade)>500;
特殊过滤的思路是，过滤掉不可能的记录。总分大于500，最高分必须大于100，或者说存在一行，大于100
可以改写为，select name, paillier_sum(grade) from student group by name having max(grade)>100;
同时把聚合结果取回到本地，进行本地过滤。
############################################################################################################################


SBT_OPTS="-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M"
java $SBT_OPTS -jar /home/niuzibin/work/apps/sbt/bin/sbt-launch.jar "$@"

############################################################################################################################
把代码搞上去



############################################################################################################################
actor模型



############################################################################################################################
scala



############################################################################################################################
libraryDependencies ++= Seq(
  "postgresql" % "postgresql" % "9.1-901-1.jdbc4",
  "org.specs2" %% "specs2" % "2.4.17" % "test",
  "net.liftweb" %% "lift-json" % "3.0.1"
)
############################################################################################################################
嵌套SQL语句的测试
create database yytest;
use yytest;
create table student(id enc int,name enc varchar(64));
insert into student value(1,"Andy"),(1,"Bill"),(3,"Caroline"),(4,"David");
create table teacher(id enc int,name enc varchar(64));
insert into teacher value(1,"Mr Zhang"),(2,"Mrs Wang"),(3,"Mr Li"),(4,"Mrs Zhao");
create table cource(id enc int,name enc varchar(64));
insert into cource value(1,"Chinese"),(2,"English"),(3,"Math"),(4,"Physics");
create table student_teacher_cource(studentId enc int, teacherId enc int, courseId enc int);
insert into student_teacher_cource value(1,2,1),(2,2,3),(3,2,2),(4,2,3);

select * from student;
select * from student where id = (select studentId from student_teacher_cource where courseId=1);


select * from student where id = (select id from student where id=1);

select * from student where id = (select id from student where id=(select id from student where id=1));


select `yytest`.`student_teacher_cource`.`studentIdoEQ` from `yytest`.`student_teacher_cource` where (`yytest`.`student_teacher_cource`.`courseIdoEQ` = 16618621350731960634);

select `yytest`.`student`.`idoEQ`,`yytest`.`student`.`nameoEQ` from `yytest`.`student` where (`yytest`.`student`.`idoEQ` = 16618621350731960634);

############################################################################################################################
select name from staff where salary > 5000;
select sum(salary) from staff;

select department, sum(salary) as department_total_salary from staff group by department having department_total_salary>100000;



select department, sum(salary) as department_total_salary from staff group by department having department_total_salary>
(select sum(salary) from staff where department='B') order by department_total_salary;

SELECT PAILLIER_SUM(price_paillier) AS total
FROM orders
GROUP BY order_id_det


create table staff(id int, name varchar(64), salary float, department varchar(64));
insert into staff value(1,"Andy",1200,"A"),(2,"Bill",1200,"B"),(3,"Caroline",2500,"A"),(4,"David",1200,"B");

insert into staff value(5,"Eric",1200,"c"),(6,"Frank",6700,"c"),(7,"Green",2500,"D"),(8,"Hill",1300,"D");



create table staff(id int, name varchar(64),salary float, department varchar(64),subcompany varchar(64));
insert into staff value(1,  "Andy",     12000.00,  "R&D department",      	"Hangzhou Branch");
insert into staff value(2,  "Bill",     13000.00,  "R&D department",      	"Hangzhou Branch");
insert into staff value(3,  "Caroline", 11000.00,  "Business department", 	"Hangzhou Branch");
insert into staff value(4,  "David",    14000.00,  "Business department", 	"Hangzhou Branch");
insert into staff value(5,  "Eric",     16000.00,  "Management department", "Hangzhou Branch");
insert into staff value(6,  "Frank",    15000.00,  "Management department", "Hangzhou Branch");
insert into staff value(7,  "Gavin",    17000.00,  "Financial department",  "Hangzhou Branch");
insert into staff value(8,  "Hill",     19000.00,  "Financial department",  "Hangzhou Branch");
insert into staff value(9,  "Ivan",     12000.00,  "R&D department",        "Beijing Branch");
insert into staff value(10, "Jack",     11000.00,  "R&D department",        "Beijing Branch");
insert into staff value(11, "Kent",     13000.00,  "R&D department",        "Beijing Branch");
insert into staff value(12, "Leo",      15000.00,  "R&D department",        "Beijing Branch");



select department, sum(salary) as department_total 
from staff 
where 
subcompany='杭州分公司' 
group by department 
having department_total>
(
	select sum(salary) from staff where subcompany='杭州分公司' and department='市场部门'
) 
order by department_total desc;


select sum(salaryoADD) from staff where 

subcompanyoDET=DET_ENC('杭州分公司') 



select department, sum(salary) as department_total from staff where subcompany='杭州分公司' group by department 




select department, sum(salary) as department_total from staff 
where 
subcompany='杭州分公司' 
group by department 
having department_total>
(
select sum(salary) from staff where subcompany='杭州分公司' and department='市场部门'
) 
order by department_total desc;


subcompanyoDET='xxx' and departmentoDET='xxx'


select sum(salary) from staff where subcompany='Hangzhou Branch' and department='Business department'

############################################################################################################################
create table staff(id enc int, name enc varchar(64), salary enc float, department enc varchar(64),subcompany enc varchar(64));
insert into staff value(1,  "Andy",     12000.00,  "R&D department",      	"Hangzhou Branch");
insert into staff value(2,  "Bill",     13000.00,  "R&D department",      	"Hangzhou Branch");
insert into staff value(3,  "Caroline", 11000.00,  "Business department", 	"Hangzhou Branch");
insert into staff value(4,  "David",    14000.00,  "Business department", 	"Hangzhou Branch");
insert into staff value(5,  "Eric",     16000.00,  "Management department", "Hangzhou Branch");
insert into staff value(6,  "Frank",    15000.00,  "Management department", "Hangzhou Branch");
insert into staff value(7,  "Gavin",    17000.00,  "Financial department",  "Hangzhou Branch");
insert into staff value(8,  "Hill",     19000.00,  "Financial department",  "Hangzhou Branch");
insert into staff value(9,  "Ivan",     12000.00,  "R&D department",        "Beijing Branch");
insert into staff value(10, "Jack",     11000.00,  "R&D department",        "Beijing Branch");
insert into staff value(11, "Kent",     13000.00,  "R&D department",        "Beijing Branch");
insert into staff value(12, "Leo",      15000.00,  "R&D department",        "Beijing Branch");


select sum(salary) from staff where subcompany='Hangzhou Branch' and department='Business department';


select department, sum(salary) as department_total 
from staff 
where 
subcompany='Hangzhou Branch' 
group by department 
having department_total>
(
	select sum(salary) from staff where subcompany='Hangzhou Branch' and department='Business department'
) 
order by department_total desc;


select cryptdb_agg(`yytest`.`staff`.`salaryoADD`,'....:.z.P#|..!.9 Z%{..!U...D..n.....q.\\X..z.t..Q.B9...]..vo.).:{.B..0.#J.       q+..cM....MR....U@.z..O.....r.....b....^... .n.A..T<..') from `yytest`.`staff` where ((`yytest`.`staff`.`subcompanyoEQ` = '.N..q=d..       4\rO...') and (`yytest`.`staff`.`departmentoEQ` = '2...L.].1.>.d._.b.1....G...sKi.T'))


subcompanyoDET = '.N..q=d..       4\rO...' and departmentoDET = '2...L.].1.>.d._.b.1....G...sKi.T'


select sum(salaryoADD) from staff where subcompanyoEQ = '.N..q=d..       4\rO...' and departmentoEQ = '2...L.].1.>.d._.b.1....G...sKi.T';


select department, sum(salary) as department_total from staff where subcompany='Hangzhou Branch' group by department;


select departmentoEQ, sum(salaryoADD) from staff where subcompanyoEQ = '.N..q=d..     4\rO...' group by departmentoEQ
############################################################################################################################
select nameoEQ from staff where salaryoORDER > 6291927251322894654;

select sum(salaryoADD) from staff;

select name from staff where salary = (select salary ...);

select name from staff where salary = (select sum(salary) ...);

create table staff(id int, name varchar(64),salary float, department varchar(64),subcompany varchar(64),primary key(id));

############################################################################################################################
select a1 from t1 where a1 = 
(
	select max(b1) from t2 where b1 > 
	(
		select sum(c1) from t3 where c1 = const;
	)
)
############################################################################################################################
同步、异步、阻塞、非阻塞、select、poll、epoll

https://www.zhihu.com/question/19732473


老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。1 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。3 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。

在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。



select、poll、epoll都是同步阻塞。


异步
linux AIO
windows IOCP
.NET BeginInvoke/EndInvoke
回调处理数据，才是异步IO


select、poll、epoll都是同步
班长收作业，epoll遍历的集合变小了，

是把阻塞点改变了位置。

select、poll、epoll本身都是阻塞的。

select外部阻塞，内部不阻塞，监视的socket是非阻塞的。

I/O多路复用：虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。
select一次调用，肯定要拿到，可读条件。



阻塞式I/O；
非阻塞式I/O；

############################################################################################################################



