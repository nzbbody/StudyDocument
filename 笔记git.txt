###########################################################################################################################
如何测试embed_tool
1、先清空shadow目录和远端mysql中的数据库
2、启动proxy，调用测试脚本，生成shadow目录
3、把【1】中的aaa目录清空，scp拷贝shadow过去，导出aaa.sql文件。
4、导出xml文件，清空shadow_2，导入shadow_2
5、把【1】中的aaa目录清空，scp拷贝shadow过去，导出bbb.sql文件。
6、对照一把sql文件
7、使用shadow进行测试
8、然后再使用shadow_2测试
	

###########################################################################################################################
密码学有关
密码学6个重要工具：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器

###########################################################################################################################
https不可用
1、https不可用
	niuzibin@ubuntu:~/work/FLKDBEnc$ sudo git clone https://192.168.10.99/FLKDBEnc/FLKWebCrypt
	Cloning into 'FLKWebCrypt'...
	fatal: unable to access 'https://192.168.10.99/FLKDBEnc/FLKWebCrypt/': gnutls_handshake() failed: Handshake failed
2、使用git@方式
	https://192.168.10.99/profile/keys
	找到generate it
	本地执行 
	ssh-keygen -t rsa -C "niuzibin@flksec.com"
	cat ~/.ssh/id_rsa.pub
3、产生的结果拷贝到 Key，然后add
4、本地执行 git clone git@192.168.10.99:FLKDBEnc/FLKWebCrypt.git	
###########################################################################################################################
CLion缺少库，需要export怎么办？
1、CLion报错，could not find java
2、加上export就可以了，但是在CLion不知道在哪里添加
3、换一种思路，在 .bashrc增加export，然后在shell脚本中，执行 source .bashrc
	进入clion的执行路径，执行
	/home/niuzibin/work/apps/clion-2016.1.1/bin/clion.sh

###########################################################################################################################
kms密钥管理服务器
1、kms是密钥管理服务器，需要向kms获取密钥，是否支持用户设置？
2、要向kms获取密钥，需要一组参数，这组参数确定密钥
3、客户端和kms交互，需要会话密钥，这就涉及密钥配送的问题，解决这个问题，使用公钥密码，向服务端请求公钥。
4、客户端请求，使用服务端的公钥SM2，对会话密钥加密。
5、考虑到会话密钥的


3、获取过程是经过网络的，如果请求是明文，第三方可以截取到，存在风险。
4、怎么解决？
	客户端的请求要加密，服务端先传一个公钥。
5、服务端传输的密钥，也需要加密
	需要客户端传输密钥
6、
	
	
###########################################################################################################################
wiki编辑
1、添加主题
	http://192.168.10.70/doku.php?id=sidebar

###########################################################################################################################
重要的错误
安装sudo apt install libmysqld-dev
导致assert(0 == mysql_thread_init());//初始化线程环境，断言失败



###########################################################################################################################
同时生成静态库和动态库



###########################################################################################################################
merge
1、如果没有分叉，从dev合并，就是 Fast-forward
2、本地合并，存在冲突。
	
###########################################################################################################################
origin
1、origin是个远程地址，通过下面的语句可以看到
	root@ubuntu:/home/disk1/GitTest# git remote -v
	origin  https://github.com/nzbbody/GitTest (fetch)
	origin  https://github.com/nzbbody/GitTest (push)
###########################################################################################################################
git介绍
1、svn是集中式版本控制，git是分布式版本控制
2、svn记录文件的差异，git是包括文件的快照，如果没有变化，从上一次引用下来。




###########################################################################################################################
ope join
create database yytest;
------------------------------------------------------------------------------------------------------------
use yytest;
drop if exists table course;
create table course(id enc int, name enc varchar(64), chinese enc int, `math` enc int, english enc int);
insert into course(id,name,chinese,math,english) value(1,"Andy", 70,80,90);
insert into course(id,name,chinese,math,english) value(1,"Bill", 74,74,70);
insert into course(id,name,chinese,math,english) value(1,"Caroline", 80,85,89);
insert into course(id,name,chinese,math,english) value(1,"David", 80,75,74);
insert into course(id,name,chinese,math,english) value(1,"Eric", 79,76,84);
insert into course(id,name,chinese,math,english) value(1,"Frank", 85,72,73);
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
use yytest;
drop if exists table course2;
create table course2(id enc int, name enc varchar(64), chinese enc int, `math` enc int, english enc int);
insert into course2(id,name,chinese,math,english) value(1,"Andy", 68,80,90);
insert into course2(id,name,chinese,math,english) value(1,"Bill", 75,71,70);
insert into course2(id,name,chinese,math,english) value(1,"Caroline", 81,85,89);
insert into course2(id,name,chinese,math,english) value(1,"David", 81,75,74);
insert into course2(id,name,chinese,math,english) value(1,"Eric", 80,76,84);
insert into course2(id,name,chinese,math,english) value(1,"Frank", 86,72,73);
------------------------------------------------------------------------------------------------------------


select course.*, course2.* from course, course2 where course.name > course2.name and course.chinese > course2.chinese;


select * from course;
select * from course where chinese > 75;

UPDATE `yytest`.table_PTKLRHEBIO    SET BIYJSNVOVGoOrder = cast(cryptdb_decrypt_int_sem(`yytest`.`table_PTKLRHEBIO`.`BIYJSNVOVGoOrder` AS `BIYJSNVOVGoOrder`,'.SO\Z..>.s{^[....',`yytest`.`table_PTKLRHEBIO`.`cdb_saltOZVHWSXTKN` AS `cdb_saltOZVHWSXTKN`) as unsigned);

select * from course where chinese = math;

select * from course where chinese > math;
思考，在哪里剥的洋葱？


OPE存在的问题
1、目前的OPE只支持 select * from course where chinese > 75;
	不支持 select * from course where chinese > math;
	也就是说，支持和常数的比较，不支持和其他字段的比较。
2、为什么？
	要支持OPE操作，必须使用的密钥相同，如果不相同肯定不行。
	目前不同字段OPE算法的密钥是不同的，产生密钥使用seedkey和扩展的字段名（这个是随机的），
	如果要支持不同字段的OPE操作，字段名这个参数必须相同。
3、但是这样就不安全了，支持OPE的不同字段，使用相同的参数，产生相同的密钥。
4、cryptdb有可能是故意不支持的。
5、支持的功能和安全性相互冲突，必须找到一个平衡点。



考虑不同表？

create table t1(id enc int);

select cryptdb_decrypt_int_ope(GAAAROSNIEoOrder,'111',cdb_saltGYIIPPWTGJ) from table_KJSSJVNTFI;


###########################################################################################################################
git fetch pull push再去了解一下


###########################################################################################################################
diff命令
1、diff比较分支，必须是已经提交的分支
2、merge只能是merge，提交的分支




###########################################################################################################################
加密模式的区别
1、SENSITIVE等级最高，BEST_EFFORT相对于SENSITIVE，只是多了一个洋葱，支持剥到明文，PLAIN就是明文。
2、BEST_EFFORT和SENSITIVE，会根据实际需要配置洋葱层，在使用的过程中，为了支持，会剥掉洋葱。





###########################################################################################################################
DETJOINFactory 和 DETFactory 什么区别？
std::unique_ptr<EncLayer>
DETFactory::create(const Create_field &cf, const std::string &key)
{
    if (isMySQLTypeNumeric(cf)) {
        if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            FAIL_TextMessageError("decimal support is broken");
        } else {
            return std::unique_ptr<EncLayer>(new DET_int(cf, key));
        }
    } else {
        return std::unique_ptr<EncLayer>(new DET_str(cf, key));
    }
}

std::unique_ptr<EncLayer>
DETFactory::deserialize(unsigned int id, const SerialLayer &sl)
{
    if ("DET_int" == sl.name) {
        return DET_abstract_integer::deserialize<DET_int>(id,
                                                       sl.layer_info);
    } else if ("DET_dec" == sl.name) {
        FAIL_TextMessageError("decimal support broken");
    } else if ("DET_str" == sl.name) {
        return std::unique_ptr<EncLayer>(new DET_str(id, sl.layer_info));
    } else {
        FAIL_TextMessageError("Unknown type for DET deserialization!");
    }
}

###########################################################################################################################
MySQL的UDF
1、MySQL的UDF(user-defined function)，用户自定义函数，





###########################################################################################################################
ope join
create database yytest;
------------------------------------------------------------------------------------------------------------
use yytest;


create table grade1(id enc int, name enc varchar(64), chn enc int, `math` enc int);
insert into grade1(id,name,chn,math) value(1,"Andy", 70,75);
insert into grade1(id,name,chn,math) value(2,"Bill", 75,74);
insert into grade1(id,name,chn,math) value(3,"Caroline", 80,78);
insert into grade1(id,name,chn,math) value(4,"David", 85,90);


create table grade2(id enc int, name enc varchar(64), chn enc int, `math` enc int);
insert into grade2(id,name,chn,math) value(1,"Andy", 72,73);
insert into grade2(id,name,chn,math) value(2,"Bill", 78,72);
insert into grade2(id,name,chn,math) value(3,"Caroline", 76,90);
insert into grade2(id,name,chn,math) value(4,"David", 88,76);



create table grade3(id enc int, name enc varchar(64), lastname enc varchar(64),chn enc int, `math` enc int);
insert into grade3(id,name,lastname,chn,math) value(1,"Andy", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(2,"Bill", "James",75,74);
insert into grade3(id,name,lastname,chn,math) value(3,"Caroline", "Onil",80,78);
insert into grade3(id,name,lastname,chn,math) value(4,"David", "Bill",85,90);
insert into grade3(id,name,lastname,chn,math) value(5,"Andy1", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(6,"Andy2", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(7,"Andy3", "Green",70,75);
insert into grade3(id,name,lastname,chn,math) value(8,"Andy4", "Green",70,75);



select * from grade3 where lastname > name;


###########################################################################################################################
OPE剥洋葱的细节
1、varbinary当成varchar使用
2、RND剥洋葱涉及到salt，其它的剥洋葱不涉及
3、由于加上了OPEJOIN，也就是 【【【OPEJOIN】OPE】RND】
	这就要剥洋葱 OPE， RND剥掉之后，就需要剥掉OPE，秘钥不同
4、为什么不需要 OPE_str::decryptUDF ？
	static onionlayout STR_ONION_LAYOUT = 
	{
    {oDET, std::vector<SECLEVEL>({SECLEVEL::DETJOIN, SECLEVEL::DET,
                                  SECLEVEL::RND})},
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
    {oSWP, std::vector<SECLEVEL>({SECLEVEL::SEARCH})}
    // {oSWP, std::vector<SECLEVEL>({SECLEVEL::PLAINVAL, SECLEVEL::DET,
                                  // SECLEVEL::RND})}
	};
	因为string的OPE是 {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
	string--OPEJOIN-->int--OPE-->int， 这里的OPE是对int处理，所以剥掉的也是OPE_int
5、对于string的OPE操作，只能比较前面4个字节，为什么？
	因为OPE算法只对前面4个字节，加密，加密的结果是 varbinary(32), 32个字节。
6、为什么只对前面4个字节加密？
	因为string的长度是不确定的，没有办法支持加密后的结果进行OPE比较。
7、为什么对前面4个字节加密，select出来的结果，是完整的？
	因为select的是eq这个洋葱，作为判断使用的是ope洋葱。
###########################################################################################################################	
mysql的varbinary
1、select出来varbinary看到的值不是字节的值，而是字节的ASCCI值。如下：
	CREATE TABLE test1 (c1 VARBINARY(3));
	INSERT INTO test1 set c1 = 0x61;
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	+----+
	1 row in set
2、再添加一个记录，如下：
	mysql> INSERT INTO test1 set c1 = 0x31;
	Query OK, 1 row affected
	
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	| 1  |
	+----+
	2 rows in set
	注意：这里的1是ASCCI值，取值为49
###########################################################################################################################
快捷键
1、word的F4，重复上一步操作
2、excel中 Ctrl+E 操作

###########################################################################################################################
16.4 安装gitlab
不行就手动安装
手动安装已经OK

###########################################################################################################################
cmake自动生成目录lib
1、对于下面的命令，cmake自动生成目录lib
	SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

###########################################################################################################################
linux程序崩溃，没有产生dmp文件
1、一般是没有设置 ulimit -c unlimited
2、如果设置了 ulimit -c unlimited，程序崩溃，可执行程序的当前目录没有产生dmp文件，检查这个目录是否有写文件的权限。
3、如果目录有写文件的权限，则很大概率是生成在其它目录。
    检查文件 /proc/sys/kernel/core_pattern
    [root@HikvisionOS VTDUTest]# more /proc/sys/kernel/core_pattern                         
    /opt/components_core/core-%e-%p-%t
4、通过下面的信息，确认崩溃如下：
    [root@HikvisionOS niuzb]# cat /var/log/messages |grep main
    Jan 29 14:52:38 localhost kernel: traps: main[10196] trap divide error ip:4005c1 sp:7fff383a1a60 error:0 in main[400000+1000]
    [root@HikvisionOS niuzb]# ll /opt/components_core/        
    -rw------- 1 root root     413696 1月  29 14:52 core-main-10196-1517208758
###########################################################################################################################
chmod的区别
1、比较 【sudo chmod 777 ./* -R】 和 【sudo chmod 777 ./ -R】，如下：
	niuzibin@ubuntu:~/111/ccc$ sudo chmod 777 ./* -R
	niuzibin@ubuntu:~/111/ccc$ ll
	total 8
	drwxrwxr-x 2 niuzibin niuzibin 4096 Jun 14 11:22 ./
	drwxrwxr-x 4 niuzibin niuzibin 4096 Jun 14 11:22 ../
	-rwxrwxrwx 1 niuzibin niuzibin    0 Jun 14 11:22 aaa*
	niuzibin@ubuntu:~/111/ccc$ sudo chmod 777 ./ -R 
	niuzibin@ubuntu:~/111/ccc$ ll
	total 8
	drwxrwxrwx 2 niuzibin niuzibin 4096 Jun 14 11:22 ./
	drwxrwxr-x 4 niuzibin niuzibin 4096 Jun 14 11:22 ../
	-rwxrwxrwx 1 niuzibin niuzibin    0 Jun 14 11:22 aaa*
2、也就是说，sudo chmod 777 ./* -R 不能改变当前目录的权限

###########################################################################################################################
链接静态库只链接调用的方法
1、动态库或者可执行文件链接静态库，只会链接调用的方法，对于没有调用的方法，不会链接。
	比如静态库暴露了10个方法，动态库或者可执行文件只调用了一个方法，只会链接这一个方法。
2、示例代码如下：
	root@ubuntu:/home/disk1/CPP_2/Link# more test.h 
	int add(int a, int b);
	int sub(int a, int b);
	
	root@ubuntu:/home/disk1/CPP_2/Link# more test1.cpp 
	#include "test.h"
	int add(int a, int b)
	{
			return a+b;
	}
	
	root@ubuntu:/home/disk1/CPP_2/Link# more test2.cpp 
	#include "test.h"
	int sub(int a, int b)
	{
			return a-b;
	}
	
	root@ubuntu:/home/disk1/CPP_2/Link# more main.cpp 
	#include "test.h"
	#include <stdio.h>
	int main()
	{
			int c = add(1,2);
			printf("c[%d]\n", c);
			return 0;
	}
3、测试如下：
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -c test1.cpp  
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -c test2.cpp
	
	root@ubuntu:/home/disk1/CPP_2/Link# ar -rc libtest.a test1.o test2.o
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -o main main.cpp -L./ -ltest
	root@ubuntu:/home/disk1/CPP_2/Link# ./main
	c[3]
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t main|grep "add"
	0000000000400562 g     F .text  0000000000000014              _Z3addii
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t main|grep "sub"
	root@ubuntu:/home/disk1/CPP_2/Link# 
	可以看到，main中并没有sub方法的代码实现。
4、如果我想把静态库中的所有方法都链接进来（这种需求比较奇葩，也会存在），怎么办？
	使用 --whole-archive编译选项，如下：
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -o main main.cpp -L./ -ltest                                           
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t main|grep "sub"      
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -o main main.cpp -Wl,--whole-archive -L./ -ltest -Wl,--no-whole-archive
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t main|grep "sub"                                                 
	0000000000400576 g     F .text  0000000000000016              _Z3subii
	可以看到，加上--whole-archive链接静态库时，会把没有调用的方法也合并过来。
5、特别说明，上面是可执行文件链接静态库，动态库链接静态库，道理也是一样的。
	动态库和可执行文件没有本质区别，可执行文件多了一个程序入口的main方法。
	测试如下：
	root@ubuntu:/home/disk1/CPP_2/Link# more aaa.cpp 
	#include "test.h"
	#include <stdio.h>
	int aaa()
	{
			int c = add(1,2);
			printf("c[%d]\n", c);
			return 0;
	}
	
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -fPIC -shared -o libaaa.so aaa.cpp -L./ -ltest                                           
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t libaaa.so |grep "sub"                  
	root@ubuntu:/home/disk1/CPP_2/Link# ll |grep libaaa.so                                
	-rwxr-xr-x  1 root root 8082 Jun 14 15:47 libaaa.so*

	root@ubuntu:/home/disk1/CPP_2/Link# g++ -fPIC -shared -o libaaa.so aaa.cpp -Wl,--whole-archive -L./ -ltest -Wl,--no-whole-archive
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t libaaa.so |grep "sub"
	0000000000000780 g     F .text  0000000000000016              _Z3subii
	root@ubuntu:/home/disk1/CPP_2/Link# ll |grep libaaa.so 
	-rwxr-xr-x  1 root root 8149 Jun 14 15:47 libaaa.so*
	可以看到，加上--whole-archive，生成的动态库，包含所有的代码实现，并且文件大小也更大。
6、特别需要注意的是：
	链接静态库的最小单元是 o文件，上面的两个方法，分别在两个cpp文件实现，生成不同的o文件
	如果生成一个o文件呢？
	示例代码
	root@ubuntu:/home/disk1/CPP_2/Link# more test1.cpp 
	#include "test.h"
	int add(int a, int b)
	{
			return a+b;
	}
	root@ubuntu:/home/disk1/CPP_2/Link# more test2.cpp 
	#include "test.h"
	int sub(int a, int b)
	{
			return a-b;
	}
	root@ubuntu:/home/disk1/CPP_2/Link# more test.cpp 
	#include "test.h"
	int add(int a, int b)
	{
			return a+b;
	}
	int sub(int a, int b)
	{
			return a-b;
	}
	测试如下：
	root@ubuntu:/home/disk1/CPP_2/Link# rm -fr *.o *.a
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -c test1.cpp
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -c test2.cpp
	root@ubuntu:/home/disk1/CPP_2/Link# ar -rc libtest.a test1.o test2.o
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -o main main.cpp -L./ -ltest
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t main |grep "sub"
	root@ubuntu:/home/disk1/CPP_2/Link# 
	root@ubuntu:/home/disk1/CPP_2/Link# rm -fr *.o *.a
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -c test.cpp
	root@ubuntu:/home/disk1/CPP_2/Link# ar -rc libtest.a test.o
	root@ubuntu:/home/disk1/CPP_2/Link# g++ -o main main.cpp -L./ -ltest
	root@ubuntu:/home/disk1/CPP_2/Link# objdump -t main |grep "sub"
	0000000000400576 g     F .text  0000000000000016              _Z3subii
	也就是说，链接的最小单元是 o文件（目标文件）
7、得出的结论是：
	链接静态库的方法，默认情况下（不加--whole-archive），是按需链接，也就是说，只链接需要的方法。
	但是，链接的最小单元是目标文件，需要目标文件中的一个方法，会把整个目标文件链接进来。
	
###########################################################################################################################
git远程分支的删除和同步
1、其他人已经删除某个分支，但是本地还能看到，这个时候fetch报错，如下：
	niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch -a                   
	develop
	* niuzibin
	remotes/origin/HEAD -> origin/develop
	remotes/origin/chenming
	remotes/origin/develop
	remotes/origin/heming
	remotes/origin/master
	remotes/origin/niuzibin
	remotes/origin/patch-1
	remotes/origin/patch-2
	remotes/origin/patch-3
	remotes/origin/patch-4
	remotes/origin/revert-77cdc6fe
	remotes/origin/revert-fa155359
	remotes/origin/tuchengyu
	remotes/origin/tuchengyu2
	remotes/origin/yangyang
	remotes/origin/yogurt
	remotes/origin/ywn
	
	niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ sudo git fetch origin tuchengyu
	fatal: Couldn't find remote ref tuchengyu
	Unexpected end of command stream
2、这个错误的原因是，fetch已经删除的分支
3、如何同步呢？
	执行 git fetch -p，如下：
	From https://192.168.10.99/FLKDBEnc/FLKCDP
	x [deleted]         (none)     -> origin/patch-2
	x [deleted]         (none)     -> origin/patch-3
	x [deleted]         (none)     -> origin/patch-4
	x [deleted]         (none)     -> origin/tuchengyu
	这个时候 git branch -a，就会少一些分支
4、查看分支的关联，如下：
	niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch -vv
	develop  0c0c9a2 [origin/develop: behind 119] Merge branch 'chenming' into 'develop'
	* niuzibin 4463d6a [origin/niuzibin] 删除无用的方法
###########################################################################################################################
git忽略文件权限的检查
1、git config core.fileMode false
2、可以查看配置文件
	niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ cat .git/config 
	[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
###########################################################################################################################
本地创建分支，并和远程关联
1、示例如下：
niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch -a
* develop
  niuzibin
  remotes/origin/HEAD -> origin/develop
  remotes/origin/chenming
  remotes/origin/develop
  remotes/origin/heming
  remotes/origin/master
  remotes/origin/niuzibin
  remotes/origin/patch-1
  remotes/origin/revert-77cdc6fe
  remotes/origin/revert-fa155359
  remotes/origin/tuchengyu2
  remotes/origin/yangyang
  remotes/origin/yogurt
  remotes/origin/ywn
  remotes/origin/ywn1
	
niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch tuchengyu2
niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch -vv
* develop    dc5f079 [origin/develop] Merge branch 'yangyang' into 'develop'
  niuzibin   4463d6a [origin/niuzibin] 删除无用的方法
  tuchengyu2 dc5f079 Merge branch 'yangyang' into 'develop'
  
niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch --set-upstream-to origin/tuchengyu2 tuchengyu2
Branch tuchengyu2 set up to track remote branch tuchengyu2 from origin.
niuzibin@ubuntu:~/work/FLKDBEnc/FLKCDP$ git branch -vv
* develop    dc5f079 [origin/develop] Merge branch 'yangyang' into 'develop'
  niuzibin   4463d6a [origin/niuzibin] 删除无用的方法
  tuchengyu2 dc5f079 [origin/tuchengyu2: behind 14] Merge branch 'yangyang' into 'develop'

	
###########################################################################################################################	
itemTypes.reg(Item::Type::FUNC_ITEM, *this);
在这里注册

















