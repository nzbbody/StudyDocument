###########################################################################################################################
如何测试embed_tool
1、先清空shadow目录和远端mysql中的数据库
2、启动proxy，调用测试脚本，生成shadow目录
3、把【1】中的aaa目录清空，scp拷贝shadow过去，导出aaa.sql文件。
4、导出xml文件，清空shadow_2，导入shadow_2
5、把【1】中的aaa目录清空，scp拷贝shadow过去，导出bbb.sql文件。
6、对照一把sql文件
7、使用shadow进行测试
8、然后再使用shadow_2测试
	

###########################################################################################################################
密码学有关
密码学6个重要工具：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器


###########################################################################################################################
kms密钥管理服务器
1、kms是密钥管理服务器，需要向kms获取密钥，是否支持用户设置？
2、要向kms获取密钥，需要一组参数，这组参数确定密钥
3、客户端和kms交互，需要会话密钥，这就涉及密钥配送的问题，解决这个问题，使用公钥密码，向服务端请求公钥。
4、客户端请求，使用服务端的公钥SM2，对会话密钥加密。
5、考虑到会话密钥的


3、获取过程是经过网络的，如果请求是明文，第三方可以截取到，存在风险。
4、怎么解决？
	客户端的请求要加密，服务端先传一个公钥。
5、服务端传输的密钥，也需要加密
	需要客户端传输密钥
6、
	

###########################################################################################################################
重要的错误
安装sudo apt install libmysqld-dev
导致assert(0 == mysql_thread_init());//初始化线程环境，断言失败



###########################################################################################################################
同时生成静态库和动态库



###########################################################################################################################
merge
1、如果没有分叉，从dev合并，就是 Fast-forward
2、本地合并，存在冲突。
	
###########################################################################################################################
origin
1、origin是个远程地址，通过下面的语句可以看到
	root@ubuntu:/home/disk1/GitTest# git remote -v
	origin  https://github.com/nzbbody/GitTest (fetch)
	origin  https://github.com/nzbbody/GitTest (push)


###########################################################################################################################
git fetch pull push再去了解一下


###########################################################################################################################
diff命令
1、diff比较分支，必须是已经提交的分支
2、merge只能是merge，提交的分支




###########################################################################################################################
加密模式的区别
1、SENSITIVE等级最高，BEST_EFFORT相对于SENSITIVE，只是多了一个洋葱，支持剥到明文，PLAIN就是明文。
2、BEST_EFFORT和SENSITIVE，会根据实际需要配置洋葱层，在使用的过程中，为了支持，会剥掉洋葱。





###########################################################################################################################
DETJOINFactory 和 DETFactory 什么区别？
std::unique_ptr<EncLayer>
DETFactory::create(const Create_field &cf, const std::string &key)
{
    if (isMySQLTypeNumeric(cf)) {
        if (cf.sql_type == MYSQL_TYPE_DECIMAL
            || cf.sql_type == MYSQL_TYPE_NEWDECIMAL) {
            FAIL_TextMessageError("decimal support is broken");
        } else {
            return std::unique_ptr<EncLayer>(new DET_int(cf, key));
        }
    } else {
        return std::unique_ptr<EncLayer>(new DET_str(cf, key));
    }
}

std::unique_ptr<EncLayer>
DETFactory::deserialize(unsigned int id, const SerialLayer &sl)
{
    if ("DET_int" == sl.name) {
        return DET_abstract_integer::deserialize<DET_int>(id,
                                                       sl.layer_info);
    } else if ("DET_dec" == sl.name) {
        FAIL_TextMessageError("decimal support broken");
    } else if ("DET_str" == sl.name) {
        return std::unique_ptr<EncLayer>(new DET_str(id, sl.layer_info));
    } else {
        FAIL_TextMessageError("Unknown type for DET deserialization!");
    }
}


###########################################################################################################################
OPE剥洋葱的细节
1、varbinary当成varchar使用
2、RND剥洋葱涉及到salt，其它的剥洋葱不涉及
3、由于加上了OPEJOIN，也就是 【【【OPEJOIN】OPE】RND】
	这就要剥洋葱 OPE， RND剥掉之后，就需要剥掉OPE，秘钥不同
4、为什么不需要 OPE_str::decryptUDF ？
	static onionlayout STR_ONION_LAYOUT = 
	{
    {oDET, std::vector<SECLEVEL>({SECLEVEL::DETJOIN, SECLEVEL::DET,
                                  SECLEVEL::RND})},
    {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
    {oSWP, std::vector<SECLEVEL>({SECLEVEL::SEARCH})}
    // {oSWP, std::vector<SECLEVEL>({SECLEVEL::PLAINVAL, SECLEVEL::DET,
                                  // SECLEVEL::RND})}
	};
	因为string的OPE是 {oOPE, std::vector<SECLEVEL>({SECLEVEL::OPEJOIN, SECLEVEL::OPE, SECLEVEL::RND})},
	string--OPEJOIN-->int--OPE-->int， 这里的OPE是对int处理，所以剥掉的也是OPE_int
5、对于string的OPE操作，只能比较前面4个字节，为什么？
	因为OPE算法只对前面4个字节，加密，加密的结果是 varbinary(32), 32个字节。
6、为什么只对前面4个字节加密？
	因为string的长度是不确定的，没有办法支持加密后的结果进行OPE比较。
7、为什么对前面4个字节加密，select出来的结果，是完整的？
	因为select的是eq这个洋葱，作为判断使用的是ope洋葱。
###########################################################################################################################	
mysql的varbinary
1、select出来varbinary看到的值不是字节的值，而是字节的ASCCI值。如下：
	CREATE TABLE test1 (c1 VARBINARY(3));
	INSERT INTO test1 set c1 = 0x61;
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	+----+
	1 row in set
2、再添加一个记录，如下：
	mysql> INSERT INTO test1 set c1 = 0x31;
	Query OK, 1 row affected
	
	mysql> select c1 from test1;
	+----+
	| c1 |
	+----+
	| a  |
	| 1  |
	+----+
	2 rows in set
	注意：这里的1是ASCCI值，取值为49
###########################################################################################################################
快捷键
1、word的F4，重复上一步操作
2、excel中 Ctrl+E 操作


###########################################################################################################################
cmake自动生成目录lib
1、对于下面的命令，cmake自动生成目录lib
	SET(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)


###########################################################################################################################	
思考洋葱的流程
1、考虑 select * from grade1 where chn > math; 流程是什么？
2、通过抓包发现，上面的sql语句重写为
	select `yytest`.`table_RINDNVZYLV`.`RQDCHMVSRGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltSTCMIHZRPQ`,`yytest`.`table_RINDNVZYLV`.`MDSBNIFRBHoEq`,`yytest`.`table_RINDNVZYLV`.`BVGEQNNIUDoEq`,`yytest`.`table_RINDNVZYLV`.`JBECZAOQOGoEq`,`yytest`.`table_RINDNVZYLV`.`cdb_saltWMPCQHRDPL` from `yytest`.`table_RINDNVZYLV` where (`yytest`.`table_RINDNVZYLV`.`MRTWUKQORQoOrder` > `yytest`.`table_RINDNVZYLV`.`GCLJSYADDKoOrder`)
3、我先思考，如果是自己做，思路是什么？
	a、要把*转化为对应的字段，一个字段扩展为多个洋葱，我使用哪一个洋葱呢？
		要选用加密过程没有信息丢失的洋葱，也就是说，可以解密的。OPE加密就会信息丢失，对于string只取前面4个字节。
		因此，这里选用eq洋葱，把*转化为每个字段的eq洋葱，因为解密还涉及到盐值，所以要select盐值字段。
	b、chn > math 涉及到两个洋葱比较，大于号决定了使用OPE洋葱，chn和math使用对应的OPE洋葱，而且要剥掉RND，OPE，到了OPE_JOIN这一层，密钥相同，就可以比较了。
		能否支持 chn > math，需要考虑哪个洋葱，以及洋葱的最里层。如下：
		const EncSet EQ_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DET, NULL)},
				{oOPE,   LevelFieldPair(SECLEVEL::OPE, NULL)},
			}
		};
		
		const EncSet JOIN_EncSet = 
		{
			{
				{oPLAIN, LevelFieldPair(SECLEVEL::PLAINVAL, NULL)},
				{oDET,   LevelFieldPair(SECLEVEL::DETJOIN, NULL)},
			}
		};
		上面是初始化的洋葱集合，以及每个洋葱的最里层。
	c、select是eq洋葱，select回来的结果，也要使用eq洋葱解密。



###########################################################################################################################
【ModernCPP_01】理解模板型别推导
1、示例代码如下：
	template<typename T>
	void f(ParamType param);
	
	f(expr);
2、先增加打印类型的代码，如下：
	#include <string>
	#include <type_traits>
	#include <typeinfo>
	#ifndef _MSC_VER
	# include <cxxabi.h>
	#endif
	#include <memory>
	#include <string>
	#include <cstdlib>	
	
	template <class T>
	std::string type_name()
	{
		typedef typename std::remove_reference<T>::type TR;
		std::unique_ptr<char, void(*)(void*)> own
			(
	#ifndef _MSC_VER
			abi::__cxa_demangle(typeid(TR).name(), nullptr,
			nullptr, nullptr),
	#else
			nullptr,
	#endif
			std::free
			);
	
		std::string r;
		if (std::is_const<TR>::value)
		{
			r +="const ";
		}		
		if (std::is_volatile<TR>::value)
		{
			r +="volatile ";
		}
		r += (own!= nullptr? own.get() : typeid(TR).name());
		if (std::is_lvalue_reference<T>::value)
		{
			r +="&";
		}
		if (std::is_rvalue_reference<T>::value)
		{
			r +="&&";
		}
	
		return r;
	}
3、考虑第一种情况，ParamType是个指针或者引用，但不是万能引用
	a、若expr具有引用型别，现将引用部分去掉
	b、然后，对expr和ParamType的型别执行模式匹配，来决定T的型别
	



###########################################################################################################################
CItemMath_One和CItemStrconv








###########################################################################################################################
template<class CB>
ope_domain_range
OPE::search(CB go_low)
{
    blockrng<AES> r(aesk);
/*
    return lazy_sample(to_ZZ(0), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);
                      */

   return lazy_sample(-(to_ZZ(1) << (pbits - 1)), to_ZZ(1) << pbits,
                       to_ZZ(0), to_ZZ(1) << cbits,
                       go_low, &r);

}
导致ope_join测试用例失败
###########################################################################################################################
目前确认不支持的
1、方法中是个表达式
	select floor(id+1) from grade1;
2、方法的嵌套
	select floor(sin(id)) from grade1;
3、两个参数、三个参数、参数不确定
	
4、


###########################################################################################################################
su与sudo的再次理解







###########################################################################################################################
tpcc-mysql的性能测试
1、下载源码，构建
	git clone https://github.com/Percona-Lab/tpcc-mysql.git
	进入tpcc-mysql/src目录，执行make构建，生成tpcc_load和tpcc_start可执行文件，说明构建OK
2、准备工作
	a、创建数据库  
	mysqladmin create tpcc1000 -h127.0.0.1 -P3306 -uroot -pletmein 
	b、创建相应数据表  
	mysql tpcc1000 -h127.0.0.1 -P3306 -uroot -pletmein < create_table.sql  
	c、创建索引  
	mysql tpcc1000 -h127.0.0.1 -P3306 -uroot -pletmein < add_fkey_idx.sql  	
	d、装载数据  
	./tpcc_load -h127.0.0.1 -P3306 -dtpcc1000 -uroot -pletmein -w 1 
3、执行测试
	./tpcc_start -h127.0.0.1 -P3306 -dtpcc1000 -uroot -p123321 -w1 -c32 -r10 -l60
	选项解释如下：
	-w 指定仓库数量
	-c 指定并发连接数
	-r 指定开始测试前进行warmup的时间，进行预热后，测试效果更好
	-l 指定测试持续时间
	-i  指定生成报告间隔时长
	-f 指定生成的报告文件名
	也可以生成文件如下： 
	./tpcc_start -h127.0.0.1 -P3306 -dtpcc1000 -uroot -w1 -c32 -r10 -l60 -f tpcc_mysql_20180617.log > tpcc_caseX_20180617.log 2>&1
4、表的业务逻辑
	New-Order：新订单，主要对应 new_orders 表
	Payment：支付，主要对应 orders、history 表
	Order-Status：订单状态，主要对应 orders、order_line 表
	Delivery：发货，主要对应 order_line 表
	Stock-Level：库存，主要对应 stock 表
	
	其他相关表：
	客户：主要对应 customer 表
	地区：主要对应 district 表
	商品：主要对应 item 表
	仓库：主要对应 warehouse 表
5、报告分析
***************************************
*** ###easy### TPC-C Load Generator ***
***************************************
option h with value '1.2.3.4'   -- 主机
option P with value '3306'             -- 端口
option d with value 'tpcc10'         -- 数据库
option u with value 'tpcc'             -- 账号
option p with value 'tpcc'             -- 密码
option w with value '10'                 -- 仓库数
option c with value '64'                 -- 并发线程数
option r with value '30'                 -- 数据预热时长
option l with value '120'               -- 压测时长
option f with value 'tpcclog_20140921_64_THREADS.res'  -- 输出报告日志文件

     [server]: 1.2.3.4
     [port]: 3306
     [DBname]: tpcc10
       [user]: tpcc
       [pass]: tpcc
  [warehouse]: 10
 [connection]: 64
     [rampup]: 30 (sec.)
    [measure]: 120 (sec.)

RAMP-UP TIME.(30 sec.)

-- 预热结束，开始进行压测
MEASURING START.

-- 每10秒钟输出一次压测数据
  10, 8376(0):2.744|3.211, 8374(0):0.523|1.626, 838(0):0.250|0.305, 837(0):3.241|3.518, 839(0):9.086|10.676
  20, 8294(0):2.175|2.327, 8292(0):0.420|0.495, 829(0):0.206|0.243, 827(0):2.489|2.593, 827(0):7.214|7.646
…
 110, 8800(0):2.149|2.458, 8792(0):0.424|0.710, 879(0):0.207|0.244, 878(0):2.461|2.556, 878(0):7.042|7.341
 120, 8819(0):2.147|2.327, 8820(0):0.424|0.568, 882(0):0.208|0.237, 881(0):2.483|2.561, 883(0):7.025|7.405
-- 以逗号分隔，共6列
-- 第一列，第N次10秒
-- 第二列，总成功执行压测的次数(总推迟执行压测的次数):90%事务的响应时间|本轮测试最大响应时间
-- 第三列，新订单业务成功执行次数(推迟执行次数):90%事务的响应时间|本轮测试最大响应时间
-- 第四列，支付业务的结果，后面几个的意义同上
-- 第五列，发货业务的结果，后面几个的意义同上
-- 第六列，库存业务的结果，后面几个的意义同上

-- 压测结束
STOPPING THREADS................................................................

   -- 第一次粗略结果统计
  [0] sc:100589  lt:0  rt:0  fl:0    -- New-Order，新订单业务成功(success,简写sc)次数，延迟(late,简写lt)次数，重试(retry,简写rt)次数，失败(failure,简写fl)次数
  [1] sc:100552  lt:0  rt:0  fl:0    -- Payment，支付业务统计，其他同上
  [2] sc:10059  lt:0  rt:0  fl:0    -- Order-Status，订单状态业务统计，其他同上
  [3] sc:10057  lt:0  rt:0  fl:0    -- Delivery，发货业务统计，其他同上
  [4] sc:10058  lt:0  rt:0  fl:0    -- Stock-Level，库存业务统计，其他同上
 in 120 sec.

    -- 第二次粗略统计结果，其他同上
  [0] sc:100590  lt:0  rt:0  fl:0 
  [1] sc:100582  lt:0  rt:0  fl:0 
  [2] sc:10059  lt:0  rt:0  fl:0 
  [3] sc:10057  lt:0  rt:0  fl:0 
  [4] sc:10059  lt:0  rt:0  fl:0 

 (all must be [OK])       -- 下面所有业务逻辑结果都必须为 OK 才行
 [transaction percentage]
        Payment: 43.47% (>=43.0%) [OK]      -- 支付成功次数(上述统计结果中 sc + lt)必须大于43.0%，否则结果为NG，而不是OK
   Order-Status: 4.35% (>= 4.0%) [OK]       -- 订单状态，其他同上
       Delivery: 4.35% (>= 4.0%) [OK]       -- 发货，其他同上
    Stock-Level: 4.35% (>= 4.0%) [OK]       -- 库存，其他同上
 [response time (at least 90% passed)]      -- 响应耗时指标必须超过90%通过才行
      New-Order: 100.00%  [OK]              -- 下面几个响应耗时指标全部 100% 通过
        Payment: 100.00%  [OK]
   Order-Status: 100.00%  [OK]
       Delivery: 100.00%  [OK]
    Stock-Level: 100.00%  [OK]


                 50294.500 TpmC                      -- TpmC结果值
注：tpm是transactions per minute的简称；C指TPC中的C基准程序。


###########################################################################################################################
tpcc-mysql测试cryptDB
1、创建数据库
	mysqladmin create yytest -h127.0.0.1 -P3307 -uroot -pletmein 
2、添加表
	mysql yytest -h127.0.0.1 -P3307 -uroot -pletmein < create_table.sql
3、加载数据
	./tpcc_load -h127.0.0.1 -P3307 -dyytest -uroot -pletmein -w1


###########################################################################################################################
push、fetch、pull
1、push做的事情
	a、修改本地的 origin/master
	b、提交到远程
2、示例如下：
	niuzibin@ubuntu:/home/disk1/GitTest$ git log -4 --oneline --decorate 
	8cbb6c4 (HEAD, master) a
	5109ccf (origin/master, origin/HEAD) b
	b87db1d a
	1e2d2d6 a
	niuzibin@ubuntu:/home/disk1/GitTest$ git diff origin/master master  
	diff --git a/readme.txt b/readme.txt
	index ccc3e7b..db754db 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-aaaaa
	+bbbbb
	niuzibin@ubuntu:/home/disk1/GitTest$ sudo git push origin master:master
	Counting objects: 5, done.
	Delta compression using up to 2 threads.
	Compressing objects: 100% (2/2), done.
	Writing objects: 100% (3/3), 242 bytes | 0 bytes/s, done.
	Total 3 (delta 1), reused 0 (delta 0)
	remote: Resolving deltas: 100% (1/1), completed with 1 local object.
	To https://github.com/nzbbody/GitTest
	5109ccf..8cbb6c4  master -> master
	niuzibin@ubuntu:/home/disk1/GitTest$ git log -4 --oneline --decorate   
	8cbb6c4 (HEAD, origin/master, origin/HEAD, master) a
	5109ccf b
	b87db1d a
	1e2d2d6 a
	niuzibin@ubuntu:/home/disk1/GitTest$ git diff origin/master master     
	niuzibin@ubuntu:/home/disk1/GitTest$ 
3、fetch做的事情
	仅仅修改本地的origin/master，也就是把远程master的数据拿回来
4、示例如下：
	niuzibin@ubuntu:/home/disk1/GitTest$ git fetch origin master
	remote: Counting objects: 3, done.
	remote: Compressing objects: 100% (1/1), done.
	remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0
	Unpacking objects: 100% (3/3), done.
	From https://github.com/nzbbody/GitTest
	* branch            master     -> FETCH_HEAD
	8cbb6c4..c1e2a1e  master     -> origin/master
	niuzibin@ubuntu:/home/disk1/GitTest$ git diff origin/master master  
	diff --git a/readme.txt b/readme.txt
	index 1188fe1..db754db 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1 +1 @@
	-ccccc
	+bbbbb
5、需要merge一下
	git merge origin/master
6、pull做的事情
	【git pull origin master】 = 【git fetch origin master】 + 【git merge origin/master】


###########################################################################################################################
有一个重大的问题如下：

update导致其他的字段，发生变化，需要修改一下，先记录一下。
mysql> select * from warehouse;                       
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = 6 WHERE w_id = 1;        
Query OK, 1 row affected (0.00 sec)

mysql> select * from warehouse;                      
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.12  | 6     |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

mysql> UPDATE warehouse SET w_ytd = w_ytd + 6 WHERE w_id = 1;
Query OK, 1 row affected (0.03 sec)

mysql> select * from warehouse;                              
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| w_id | w_name    | w_street_1     | w_street_2   | w_city       | w_state | w_zip     | w_tax | w_ytd |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
| 1    | 3WAf6foT8 | OxjIRCUDCbPSiC | fjVVJ7ZoHCsw | L3Vj0E0PQUcb | 03      | 617966913 | 0.00  | 12    |
+------+-----------+----------------+--------------+--------------+---------+-----------+-------+-------+
1 row in set (0.01 sec)

w_ytd = w_ytd + 6 导致错误，需要找一下问题。
w_tax是 float存在问题，如果是int没有问题，

那我现在怎么做？
先把w_tax 不加密，来测试一把。也不行

w_ytd = 300000.00; 是写死的，因此，我使用 SET w_ytd = 6 这种方式，来设置。

INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\').....Q.#07000Error: Bad Query: [INSERT INTO history(h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data) VALUES(3, 1, 2, 1, 1, '2018-07-04 22:13:07', 3385.000000, '.\')]
	Line 1736: Error Data: parse_sql


###########################################################################################################################
BenchmarkSQL
1、创建数据库和表
	mysqladmin create tpcc -h127.0.0.1 -P3306 -uroot -pletmein
	./runSQL.sh mysql.properties sqlTableCreates
2、加载数据
	./loadData.sh mysql.properties numWarehouses 1
3、添加索引
	./runSQL.sh mysql.properties sqlTableCreates
4、测试
	./runBenchmark.sh mysql

###########################################################################################################################
gitlab markdown
测试一下


###########################################################################################################################
批量修改图片的属性
1、全选所有图片：开始－－编辑－－查找和选择－－定位条件，点选“对象”，确定；
2、右击任一图片，大小和属性，属性选项卡，点选“对象位置”中“大小和位置随单元格而变”。


###########################################################################################################################
验证流程：
1、每个测试结果点击一下，看看是否有图片显示不对。
2、修改的代码好好检查，commit，添加详细支持的log
3、自动化跑一遍
4、push代码
5、提交 FunctionTest，添加详细的log

###########################################################################################################################
配置runner ci
https://note.youdao.com/group/#/65827312/(full:pdf/201146002)






###########################################################################################################################
涂成玉的两个安装包，自己测试一把

另外的两个deb包，util和parse，也要安装一下。
然后打包。


mysql增加 automake
还缺少 tlogin

###########################################################################################################################
内存泄漏的代码好好整理一下












###########################################################################################################################
deb包制作、安装、运行、卸载
1、准备的可执行文件，main
2、制作脚本
	#!/bin/sh
	set -x
	set -e
	
	shPath=$(cd $(dirname $0);pwd)
	cd $shPath
	
	# read -p "please input version like 1.0.0:  " version
	name="debtest"
	version="1.0.0"
	underline="_"
	platform="amd64"
	projName=${name}${underline}${version}${underline}${platform}
	debName=${projName}".deb"
	
	if [  ! -d "./dist" ] ; then
			mkdir "./dist"
	fi
	
	cd ./dist
	rm -fr *
	
	mkdir DEBIAN
	cat>"./DEBIAN/control"<<EOF
	package: $name
	version: $version
	architecture: $platform
	maintainer: niuzibin
	description: this is deb test
	EOF
	
	mkdir -p ./usr/bin/
	cp $shPath/main ./usr/bin/
3、安装
	./auto_deb.sh
	sudo dpkg -i debtest_1.0.0_amd64.deb
4、运行
	main
5、卸载
	niuzibin@ubuntu:~/222$ dpkg -l |grep debtest                
	ii  debtest                                               1.0.0                                               amd64        this is deb test
	niuzibin@ubuntu:~/222$ sudo dpkg -r debtest
	注意：卸载不是安装包的全称，而是 debtest
###########################################################################################################################

create table grade (id enc int, name enc varchar(64), chn enc int, math enc int, f1 enc float, f2 enc float, des varchar(64), primary key(id));
insert into grade value(1,"Andy",70,70,5.4,5.6,"Andy"),(2,"Bill",75,75,6.4,6.6,"Bill"),(3,"Caroline",80,80,7.4,7.6,"Caroline"),(4,"David",85,85,8.4,8.6,"David");



alter table stu add constraint fk_grade foreign key (id) references grade(id);


delimiter ;;  
create procedure proc1() 
begin 
select des  from grade;
end
;; 
delimiter ;


chn, abs(chn),f1, abs(f1),
chn, sin(chn),f1, sin(f1),
chn, cos(chn),f1, cos(f1),
chn, sign(chn),f1, sign(f1),
chn, exp(chn),f1, exp(f1),
chn, floor(chn),f1, floor(f1),
chn, ceiling(chn),f1, ceiling(f1),
chn, log(chn),f1, log(f1),
chn, log10(chn),f1, log10(f1),
chn, log2(chn),f1, log2(f1),
chn, sqrt(chn),f1, sqrt(f1),
chn, tan(chn),f1, tan(f1),
chn, cot(chn),f1, cot(f1),
chn, acos(chn),f1, acos(f1),
chn, asin(chn),f1, asin(f1),
chn, atan(chn),f1, atan(f1),
chn, degrees(chn),f1, degrees(f1),
chn, radians(chn),f1, radians(f1),



select 
chn, abs(chn),f1, abs(f1),
chn, sin(chn),f1, sin(f1),
chn, cos(chn),f1, cos(f1),
chn, sign(chn),f1, sign(f1),
chn, exp(chn),f1, exp(f1),
chn, floor(chn),f1, floor(f1),
chn, ceiling(chn),f1, ceiling(f1),
chn, log(chn),f1, log(f1),
chn, log10(chn),f1, log10(f1),
chn, log2(chn),f1, log2(f1),
chn, sqrt(chn),f1, sqrt(f1),
chn, tan(chn),f1, tan(f1),
chn, cot(chn),f1, cot(f1),
chn, acos(chn),f1, acos(f1),
chn, asin(chn),f1, asin(f1),
chn, atan(chn),f1, atan(f1),
chn, degrees(chn),f1, degrees(f1),
chn, radians(chn),f1, radians(f1) 
from grade;


proxy failed to retrieve default database


###########################################################################################################################
proxy failed to retrieve default database 这个问题，稍微处理一下

操作步骤
1、return tpcc注释掉，vi ../sqlhandler/rewrite/src/rewrite_util.cc 837行
2、调用rebuild_clear_all.sh
3、开启flkcdp，创建数据库 tpcc，然后关闭
4、直接return tpcc，true，然后 sudo make install
5、flkcdp >/dev/null 2>&1 
6、调用 test_load_flkcdp.sh
###########################################################################################################################

create table student(id enc int, name varchar(64), des enc varchar(64), chn enc int, math enc int, height enc float, weight enc float, primary key(id));
insert into student value(1,"Andy", "I am Andy", 78, 89, 175.5, 80.5);
insert into student value(2,"小明", "我来自杭州", 75, 85, 170.4, 68.5);
insert into student value(3,"Bill", "I am boy", 74, 81, 165.5, 73.5);
insert into student value(4,"小红", "我来自北京", 84, 86, 169.5, 73);


select chn, math,chn+math,height,weight, height-weight from student;
select chn, chn*2, chn/3, weight, weight*3, weight/5 from student;

create table teacher(id enc int, name varchar (64), stuid enc int,primary key(id));
alter table teacher add constraint fk_grade foreign key(stuid) references student(id);

###########################################################################################################################
中文插入失败
在mysql添加 mysqld

init-connect='SET NAMES UTF8'
skip-character-set-client-handshake
character-set-server=utf8
collation-server=utf8_general_ci

重启mysql，重新创建数据库

###########################################################################################################################
    alter table t1 add index index_c2(c2);
    或者
    create index index_c2 on t1(c2);
	
	
	
create table staff(id enc int auto_increment,name enc text,age enc int,salary enc decimal(10,2),score enc decimal(10,2),insurance decimal(10,2),fund decimal(10,2),description enc text,primary key(id));


create table staff(id enc int, name enc text,age enc int,salary enc decimal(10,2),score enc decimal(10,2),insurance decimal(10,2),fund decimal(10,2),description enc text,primary key(id));
	
create table assets(id enc int, name varchar (64), staffid enc int,primary key(id));

alter table assets add constraint fk_assets foreign key(staffid) references staff(id);

create index index_age on staff(age);
drop index index_age on staff;


alter table staff add index index_age(age);
alter table staff drop index index_age;




###########################################################################################################################





###########################################################################################################################
只演示加减乘除 以及关键词的模糊搜索
-- 创建表，添加记录
create table staff(id int, name enc varchar(64), height enc float, weight enc float, basepay enc float, meritpay enc float, des enc varchar(128));
insert into staff value(1,"滕海明",178.5,176.25,1000.50,200.35,"I am Frank, hello");
insert into staff value(2,"陈明",170.5,150.25,900.15,310.45,"我叫陈明, 我来自上海");
insert into staff value(3,"杨万年",171.5,155.25,984.15,264.45,"我是杨万年，我是安徽人，hello");
insert into staff value(4,"刘新超",172.25,165.25,635.15,561.45,"大家好，我是刘新超");
insert into staff value(5,"钟倩",162.5,100.25,844.15,190.45,"我是钟倩，九零后");
insert into staff value(6,"倪飞",173.25,163.25,987.15,256.45,"我叫倪飞，我是安徽人");
insert into staff value(7,"牛自宾",175.5,170.25,810.15,315.45,"我是牛自宾，我来自安徽");

-- 查询所有的记录
select * from staff;

-- 最大值最小值【基本工资】
select max(basepay),min(basepay) from staff;

-- 密文的加减运算【基本工资+绩效工资】
select basepay, meritpay, basepay+meritpay from staff;

-- 密文的乘除【基本工资】
select basepay, basepay*1.1, basepay/2.5 from staff;

-- 密文的关键词模糊搜索

select * from staff where name="杨万年";

select * from staff where des like "%Frank%";
select * from staff where des like "%hello";

select * from staff where des like "%安徽";
select * from staff where des like "%安徽%";

###########################################################################################################################
curl 命令 ftp








############################################################################################################################










###########################################################################################################################





